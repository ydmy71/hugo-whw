[{"content":"测试 软件测试 软件测试定义及目的 在规定条件下对程序进行操作，发现程序错误，衡量软件质量 目的就是尽可能多的发现软件缺陷\n软件测试分类 1.按开发阶段分类 单元测试，单元测试是微小规模的测试；以测试某个功能或代码块 集成测试，集成测试是指一个应用系统的各个部件的联合测试，以决定他们能否在一起共同工作并没有冲突。 部件可以是代码块、独立的应用、网络上的客户端或服务器端程序。这种类型的测试尤其与客户服务器和分布式系统有关。一般集成测试以前，单元测试需要完成。 系统测试，系统测试是基于系统整体需求说明书的黑盒类测试，应覆盖系统所有联合的部件。系统测试是针对整个产品系统进行的测试，目的是验证系统是否满足了需求规格的定义，找出与需求规格不相符合或与之矛盾的地方。 验收测试，验收测试是部署软件之前的最后一个测试操作。 在软件产品完成了单元测试、集成测试和系统测试之后，产品发布之前所进行的软件测试活动。它是技术测试的最后一个阶段，也称为交付测试。验收测试的目的是确保软件准备就绪，并且可以让最终用户将其用于执行软件的既定功能和任务。\n2.软件结构和算法角度 黑盒测试：称为功能测试，通过测试来检验每个功能是否实现，把程序比喻成黑盒，在完全不考虑程序内部实现的情况下，对接口进行测试，功能对比需求文档是否是西安。 白盒测试：对软件代码实现的细节做细致检查。程序员必须全面了解程序的内部逻辑结构，对逻辑结构进行测试 灰盒测试：介于黑，白测试之间，灰盒关注输入数据，输出数据正确性，同时也关注内部实现\n3.按软件的测试面划分 功能测试，性能测试，空间性能，时间性能\n5软件的测试周期划分 冒烟测试，回归测试，随机测试，安全测试 冒烟测试：在对一个新版本进行大规模的系统测试之前，先验证软件的基本功能是否实现，是否具备可测性 回归测试：开发人员修改bug后，修饰旧代码，重新进行测试 随机测试：所有输入的数据都是随机产生，目的模拟用户真实操作，发现边缘性错误 安全测试：开发过程完成到发布阶段，对产品进行校验，验证产品符合安全需求定义，产品质量标准\n测试用例应该包括什么内容 测试用例编号 测试项目 测试用例标题 重要级别 预置条件 测试输入 操作步骤 预期结果 实际结果 备注\n自动化测试 它是一种使用特定的软件工具和脚本，以自动执行测试用例并验证系统功能和性能的方法。 优势有，可以提高测试效率，增强测试的准确性和可靠性，提高软件质量\nJmeter可以做哪些测试 并发测试 使用同步计时器，同步计时器主要有两个参数 模拟用户的数量：并发数 超时时间：设置等待时间，如果为0则永久等待，直到满足模拟的用户数 非0的话，则等待指定时间，如果在时间内，则满足条件就释放，否则超时释放\n稳定性测试 主要作用：测试持续一段时间访问接口，测试接口的稳定性 主要配置：线程组设置循环次数永久。 添加统一随机定时器\n业务场景测试 测试多个接口调用，模拟真实场景中接口调用，证据增加统一随机定时器模拟用户真实操作，比如用户下单过程 使用事务控制器 进行管理这些接口，这些接口属于一个事务流程，只要有一个测试失败，则事务通过失败\n负载测试 测试一个接口或者一个业务场景的支持量\nJmeter主要元件 1.测试计划：是使用jmeter进行测试的起点，它是其它Jmeter测试元件的容器 2线程组：代表一定数量的用户，它可以用来模拟用户并发发送请求。实际的请求内容在Sampler中定义，它被线程组所包含 3配置元件：维护Sampler需要的配置信息，并根据实际的需要修改请求的内容。 4.前置处理器：负责在请求之前工作，常用来修改请求的配置 5.定时器：负责定义请求之间的延迟间隔。 6.取样器：是性能测试中向服务器发送请求，记录响应信息，响应时间的最小单元。 7.后置处理器：负责在请求之后工作，常用获取返回的值。 8.断言：用来判断请求响应的结果是否如用户所期望的。 9.监听器：负责收集测试结果，同时确定结果显示的方式。 10.逻辑控制器：可以自定义Jmeter发送请求的行为逻辑，它与Sampler结合使用可以模拟复杂的请求序列。\ntoken 是服务端生成的一串字符串，作为客户端进行请求的一个令牌。\n抽象工厂模式 围绕一个超级工厂创建其他工厂，该超级工厂又被称为其他工厂的工厂。 抽象工厂模式提供了一种创建一系列相关或相互依赖对象的接口，而无需指定具体实现类，通过使用抽象工厂模式，可以将客户端与具体产品的创建过程解耦，使得客户端可以通过工厂接口来创建一族产品。 结构： 抽象工厂：声明了一组用于创建产品对象的方法，每个方法对应一种产品类型，抽象工厂可以是接口或抽象类。 具体工厂：实现了抽象工厂接口，负责创建具体产品对象的实例 抽象产品：定义了一组产品对象的共同接口或抽象类，描述了产品对象的公共方法。 具体产品：实现了抽象产品接口，定义了具体产品的特定行为和属性。\n单例模式 单例模式的主要目的是限制一个类的实例化，只允许创建一个对象，这样可以在整个应用程序中共享同一个实例，从而减少资源消耗，提高性能，并方便对共享资源的管理和控制。 确保一个类只有一个实例，并提供一个全局访问点来访问该实例\n懒汉模式和饿汉模式的区别 初始化时间： 饿汉模式：在类加载的时候就实例化，即类加载只有一次，初始化时间较早。 懒汉模式：在类加载的时候没有直接实例化，而是在第一次调用指定实例方法的时候才进行实例化，因此初始化时间较晚。 线程安全性： 饿汉模式：由于在类加载的时候就实例化了，所有不存在多线程并发访问的问题，因此是线程安全的。 懒汉模式：在多线程环境下，懒汉模式本身是非线程安全的。如果多个线程同时进入了创建对象的判断条件，可能会创建多个对象。因此，懒汉模式需要通过加锁等方式保证线程安全。 资源占用和性能： 饿汉模式：在类加载的时候就创建了对象，会占用一定的内存空间，但相应的，由于资源已经初始化，第一次调用的速度也会更快，性能相对较好。 懒汉模式：会延迟加载，在第一次使用本单例才会出现实例对象，第一次调用需要做初始化，如果需要做的工作比较多，性能会有所延迟，但避免了不必要的内存占用。\n","date":"2024-06-15T17:34:23+08:00","image":"https://ydmy71.github.io/hugo-whw/p/jmeter/jmeter_hu16377613109149717053.jpg","permalink":"https://ydmy71.github.io/hugo-whw/p/jmeter/","title":"Jmeter"},{"content":"Redis Redis 首先，Redis是一个开源基于内存的高性能键值对存储系统 1 高性能：redis数据存储在内存中，因此可以能够极快的读写操作，它采用单线程模型和异步I/O,避免了多线程的竞争和阻塞，从而达到了非常高的性能。 2 数据结构多样性：redis提供了多种数据类型来支持不同的业务场景 3持久化支持：redis提高了两种持久化方式，即快照和日志追加。快照方式将Redis内存数据以二进制格式写入磁盘，而AOF则提供追加记录Redis的操作命令来实现持久化。 4发布订阅：Redis支持发布订阅模式，可以用作消息代理，发布者将消息发送到指定的频道，订阅者则可以接收和处理这些消息。 5.分布式缓存：redis可以通过主从复制和分片来实现数据分布式存储和高可用性。主从复制可以将数据复制多个从节点，实现读写分离和数据备份。而分片则可以将数据分布在多个Redis节点上，实现横向扩展和负载均衡 6事务支持 和mysql事务一样\nRedis事务和MySQL事务的原子性区别 定义与实现 Redis事务是一组命令集合，若有语法错误则整个事务放弃，运行时错误只放弃出错命令，如果出现运行时错误（例如对一个字符串进行算术运算），Redis只会放弃出现的错误的命令，而其他命令会继续执行。 Mysql事务的原子性 ，MySQL通过redo log和 undo log来实现事务的原子性，当事务开始时，Mysql会记录所有对数据修改的操作到redo og中，同时也会记录反向操作到undo log中，如果事务执行成功，redo log中的记录会被持久化到磁盘，undo log中的记录可以用于回滚事务，如果事务执行失败，Mysql可以根据undo log中的记录将数据恢复到事务开始之前的状态。 应用场景和特点 Redis事务用于保证一组命令顺序执行及一定一致性要求的场景，执行是单线程但不能保证绝对一致性 Mysql事务用于数据一致性要求高的业务场景，支持多种隔离级别，可通过锁机制保证一致性 性能与可靠性 性能上，Redis事务执行快，但复杂操作可能影响性能，Mysql事务因磁盘I/O和锁机制性能相对较低但可优化。 可靠性上，Redis事务可靠性低，可配置持久化策略提高，Mysql事务可靠性较高，通过日志和回滚保证数据完整。\nRedis源代码布局 src：包含了一些C语言编写的Redis实现 tests：包含Tcl中实现的单元测试 deps：包含Redis使用的库编译 Redis 所需的一切都在此目录中;您的系统只需要提供 、 POSIX 兼容接口和 C 编译器。值得注意的是，包含 的副本，它是 Linux 下 Redis 的默认分配器。 sever.h 定义客户端的数据结构 struct client { int fd;//客户端套接字文件描述符 sds querybuf;//累积来自客户端的请求，这些请求由 Redis 服务器根据 Redis 协议进行解析，并通过调用客户端正在执行的命令的实现来执行。 int argc;//填充客户端执行的命令，以便实现给定Redis命令的函数可以读取参数 robj **argv; redisDb *db; int flags; list *reply;是动态和静态缓冲区，用于累计服务器发送到客户端的回复，一旦文件描述符可写，这些缓冲区就以增量的方式写入套接字 // \u0026hellip; many other fields \u0026hellip; char buf[PROTO_REPLY_CHUNK_BYTES]; }\nRedis支持的数据类型 1.string 底层的数据结构为int和SDS SDS不仅可以保存文本数据，还可以保存二进制数据。 SDS获取字符串长度的时间复杂度是O(1) SDS结构 Redis的SDS API是安全的，拼接字符串不会造成缓冲区溢出。 场景：session存储 常规计数 例如文章的阅读量 SET key value GET 获取\n2.list 列表，在Redis中的list在底层实现上并不是数组，而是压缩列表或者双向链表，也就是说对于一个具有很多个元素的list来说，在头部和尾部插入一个新元素时间复杂度都是常数级别的。如果列表的个数小于512个并且每个元素的值都小于64字节。 场景：分页查询 LPUSH key value LRANGE 获取指定范围内的元素\n3.set 如果集合中的元素都是整数并且元素小于512个，redis会使用整数集合作为底层数据结构。如果不满足的画会使用哈希表作为底层数据结构。无序 场景：兴趣标签 实时的在线状态 SADD key value SMEMBERS\n4.zset 有序集合，如果有序集合的元素个数小于128个，并且每个元素的值小于64字节，redis会使用压缩列表作为底层数据结构。 场景：排行榜 ZADD ZRANGE 获取范围内的成员\n5.hash 哈希存储的就是字符串和字符串值之间的映射。 如果哈希类型元素少于512个所有制小于64字节。redis会使用压缩列表作为底层数据结构。不符合则用哈希表 HMSET key value key value HGETALL 获取 场景：用户信息\nRedis缓存 用户的数据一般都是存储在数据库上的，请求的数量一上来，数据库会奔溃，所以要用Redis作为缓存层，会给Redis里的数据设置过期时间。当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存。\n缓存雪崩 当大量缓存数据在同一时间过期或者Redis故障宕机，此时有大量的用户请求时，都无法在Redis中处理，于是直接访问数据库，导致压力骤增。 解决办法 1 均匀的设置过期时间，给这些数据的过期时间加上一个随机数. 2 互斥锁 如果发现访问的数据不在Redis里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存，记得要设置锁的超时时间。 3.后台更新缓存，可以看作缓存永久有效，并将更新缓存的工作交由后台线程固定刷新\n缓存击穿 如果缓存中的某个热点数据过期了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库。\n缓存穿透 当用户访问的数据，即不在缓存中，也不在数据库中，导致请求在访问缓存时，发现缓存缺失，在访问数据库的时候，数据库中也没有，导致数据库的压力骤增。首先是业务误操作，和黑客恶意攻击。 解决方案 1.非法请求的限制 2.缓存空值或者默认值 3.使用布隆过滤器来快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。 布隆过滤器是由位图数组和N个哈希函数组成的， 他返回存在，并不一定证明就在，但返回不存在它一定不在\nRedis如何判断key已经过期了？ 每当我们对一个key设置了过期时间时，Redis会把key带上过期时间存储到一个过期字典中，也就是说过期字典保存了数据库中所有key的时间。 过期删除策略 1，定时删除：在设置key的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行key的删除操作。优点时对内存很友好，可以使内存尽快的释放 缺点是，如果过期key较多的话，对CPU不友好。 2.惰性删除：就是不主动删除过期键，每次从数据库访问key时，都检测key是否过期，如果过期删除该key。优点是每次访问时，才会检查是否过期，对CPU时间最友好。如果key已经过期的话，只要这个过期key一直没被访问，会造成内存空间浪费。 3.定期删除 每隔一段时间随机从数据库中取出一定数量的key进行检查，并删除其中过期的key。\nRedis持久化 Redis如何实现数据不丢失，Redis读写都是在内存中，当Redis重启，内存数据会丢失，所以有了持久化,会把数据存储到磁盘。\nAOF日志 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件中。然后在重启的Redis的时候，先去读这个文件里的命令，并且执行它。 AOF写回策略 首先Redis执行完写操作命令后，会将命令追加到server.aof.buf缓冲区， 然后通过write系统调用，将aof_buf缓冲区的数据写入到AOF文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区page cache等待内核将数据写入硬盘 具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。 AOF日志过大，会触发什么机制？ Redis为了避免AOF文件越写越大，提供了AOF重写机制，当AOF文件的大小超过所设定的阈值，就会启用AOF重写机制，来压缩AOF文件，重写AOF过程是由后台子进程来完成的。 具体流程为，在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到新的AOF文件，等到全部记录完后，就将新的AOF文件替换掉现有的AOF文件，在使用重写机制后，就会读取name最新的value，然后用一条命令记录到新的AOF文件中，最终也只需要根据这个键值对当前最新状态，用一条命令去记录键值对，如果AOF重写过程中失败了，先有的AOF文件会造成污染。\nRDB快照 将某一时刻的内存数据，以二进制的方式写入磁盘。然后它是Redis提供了两个命令来生成RDB文件，分别是save和bgsave，执行save命令，就会在主线程生成RDB文件，由于和执行操作命令在同一个线程，所以如果写入RDB文件的时间太长，会阻塞主线程。 执行bgsave命令会创建一个子进程来生产RDB文件，这样可以避免主线程的阻塞。 Redis的快照是全量快照，在执行快照时，都是把内存中的所有数据都记录到磁盘中。\n写时复制 在执行bgsave命令的时候，会通过fork创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向物理内存还是一个。 如果主线程要修改共享数据的某一块数据，就会发生写时复制，于是这块数据的物理内存就会被复制一份，然后主线程在这个数据副本进行修改操作，与此同时，bgsave子进程可以继续把原来的数据写入到RDB文件。 所以发生了写时复制后，RDB快照保存的是原本的内存数据。\n混合持久化 AOF文件的前半部分是RDB格式的全量数据，后半部分是AOF格式的增量数据。 这样做的好处就是重启Redis加载数据的时候，由于前半部分是RDB内容，这样加载的时候速度会很快，然后接下来是Redis后台子进程重写AOF期间，主线程处理的操作命令，可以使得数据更少的丢失。\nRedis的主从复制 可以保证多台服务器的数据一致性，且主从服务器之间采用的时读写分离的方式 主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读的，并接受主服务器同步过来写操作命令，然后执行这条命令。 也就是说，所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的。\n哨兵模式 是一种Redis的一种运行模式，他专注于对Redis实例（主，从节点）运行状态的监控，并能够在主节点发生故障时通过一系列的机制实现选主及主从切换，实现故障转移，确保整个Redis系统的可用性。 哨兵节点负责三件事情，监控，选主，通知\n如何判断主节点真的故障了？ 哨兵每隔一秒给所有主从节点发送ping命令，当主节点收到ping命令后，会发送一个响应命令给哨兵，这样可以判断它们是否在正常运行。 一般会部署最少三个哨兵节点部署成哨兵集群，通过多个哨兵节点一起判断，就可以避免单个哨兵因为自身网络状况不好，然后误判主节点下线的情况。 选出哨兵leader 某个哨兵判断主节点客观下线以后，该哨兵回发起投票，需要满足两个条件，拿到半数以上的赞成票，拿到的票数同时还需要大于等于哨兵配置文件中的值 由哨兵leader进行主从故障转移 在已下线主节点（旧主节点）属下的所有从节点里面，挑出一个从节点，并将其转换为主节点 1.过滤掉已经离线的从节点 2.过滤掉历史网络连接状态不好的从节点 3.将剩下的从节点，进行三轮考察：优先级，复制进度，id号，在每一轮考察过程中，如果找到了一个胜出的从节点，就将其作为新主节点 4.让已下线主节点属下的所有从节点修改复制目标，需改伟复制新主机节点 5.将新主节点的IP地址和信息，通过发布订阅通知给客户端 6.继续监视旧主节点，当这个旧主节点重新上线时，将它设置伟新主机节点的从节点。\n","date":"2024-03-23T17:34:23+08:00","image":"https://ydmy71.github.io/hugo-whw/p/redis/redis_hu18150331404957497096.jpg","permalink":"https://ydmy71.github.io/hugo-whw/p/redis/","title":"Redis"},{"content":"数据结构与算法 7大排序 选择排序：时间复杂度O(n^2) 空间O(1) 不稳定 冒泡排序：时间复杂度：O(n^2) 空间复杂度：O(1) 稳定 插入排序：时间 O(n^2) 空间 O(1) 稳定 桶排序：n是原始数据的规模，m是n个数据中的最大值 时间复杂度：o（n+m）/ o（n） 空间复杂度：o（m）稳定 归并排序：时间 O(nlogn) 空间 O(n) 稳定 堆排序：时间 O(nlogn) 空间 O(1) 不稳定 快排：时间O(nlogn) 最坏O(n)空间 O(1) 不稳定\n堆 完全二叉树：若二叉树的深度为h，则除第h层外，其他层的结点全部达到最大值，且第h层的所有结点都集中在左子树。 每次插入都是将先将新数据放在数组最后，由于从这个新数据的父结点到根结点必然为一个有序的序列，现在的任务是将这个新数据插入到这个有序序列中——这就类似于直接插入排序中将一个数据并入到有序区间中。\n哈希表 哈希表是一个存储键值对的数据结构。 哈希表是通过key通过一个散列函数加工处理之后得到的一个值，这个值就是数据存放的位置， 哈希冲突 就是其他的key经过哈希函数得到的值，和之前某个key重复了\n哈希函数的特征 哈希函数最常用的方法是除留余数法f（key）%m m为表长 int f(string) 输入域无穷大，输出域是有限的 有可能不同的输入，对应相同的输出 如果输入的参数是一样的，输出是一定相同的 均匀性 类似的输入，通过打乱，然后得到均匀\n解决方法： 线性探测再散列，先存直到发现冲突的时候，f（key）+1或者+2直到找到不冲突的地方 再哈希法，换一个哈希函数 链地址法 哈希扩容 负载因子 公式为=填入表中的元素个数/哈希表的长度 当负载因子达到0.75时或0.8会触发扩容机制 创建一个两倍大小新的哈希表， 遍历原哈希表中所有元素，并重新计算它们在新表中的位置 将每个元素从旧的哈希表移动到新的哈希表对应位置 动态扩容 将扩容的操作穿插在插入操作中，先申请两倍空间，然后不迁移 插入新数据时，把老的也插入 查找数据的时，现在新的hash表中进行查找，没有在去旧的查找\n怎么才算一个好的哈希函数 尽量避免冲突， 只要改动一个字节，其哈希值也会有很大不同 高效性\nvector是如何扩容的？ GCC是二倍进行扩容 vs中是1.5倍 扩容需要先新申请一块内存空间，然后把旧内存拷贝过去，并且释放旧内存空间 不仅仅使用pushback容量不够时会扩容，resize时也会扩容。resize传入的参数不仅仅大于size的大小如果也大于容量大小时就会进行扩容\n数组和链表 从内存角度来讲的话 数组内存比链表内存所占的空间少 地址连续 链表地址不连续 由上可知 数组的查询数据比链表快 但是链表对于数组来说 删除和添加更快 大小扩展的话 链表比数组更优秀 内存利用率比数组更好 因为数组地址连续 但链表不一样\n红黑树和hashmap适用于什么情况 红黑树通常用于需要排序的键值对数据存储，它能够保持数据的有序性以及在插入和删除操作时能够保持对数据结构的平衡，从而保证最坏情况下的时间复杂度为O(log n)。红黑树适用于需要进行范围查询的场景，例如数据库索引、2-3-4树的JVM实现等。 Hashmap是一种以散列为基础的数据结构，适用于快速的查找和访问操作。当不需要数据的排序时，Hashmap是一个很好的选择，因为它的平均时间复杂度为O(1)。然而，当需要排序或者需要保持数据的有序性时，Hashmap就不适用了。 红黑树和Hashmap各自的适用情况是互补的，它们各自在特定的场景下有着优秀的表现。例如，可以使用Hashmap来快速访问，然后当发生冲突时，使用红黑树来维护一个有序的子列表。或者，可以将整个数据集合分割成多个小的子集，每个子集用Hasap管理，同时保留一个索引结构使用红黑树来快速定位子集。\nvector list map的区别 vector: 优点 支持随机访问 查询效率快 缺点 往头部或中部插入或删除元素时，为了保持原本的相对次序，插入或删除之后的所有元素都必须移动，所以插入效率比较低 适用场景：适用于对象简单，变化较小，并且频繁随机访问的场景\nlist 优点：不使用连续的内存进行存储，存储空间无限（只要内存够）。可以在任意位置插入或删除且效率高。 在内部插入、删除很快（不需要进行内存拷贝或者移动，只需要进行指针的更改） 缺点. 随机查找太慢 相比vector 占用内存比较大\nmap： 优点：使用平衡二叉树实现，便于元素查找，且能把一个值映射成另一个值。 缺点：每次插入都需要调整红黑树，效率有一定影响。 map比vector查找更快（map的内部数据结构用rb-tree实现，而用vector你只能用线性查找，效率很低,也有一种说法，关联式容器拥有自动排序能力，并不意味它们在排序方面的执行效率更高。事实上由于关联式容器每安插一个新元素，都要进行一次排序，所以速度反而不及系列容器经常采用的手\nmap 和 unordered_map的区别 map： 优点： 有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作 红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高 缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间 适用处：对于那些有顺序要求的问题，用map会更高效一些\nunordered_map： 优点： 因为内部实现了哈希表，因此其查找速度非常的快 缺点： 哈希表的建立比较耗费时间 适用处：对于查找问题，unordered_map会更加高效\npush_back和emplace_back的区别？ 首先push_back是先创建一个元素，然后将这个元素拷贝或移动到容器的尾部，整个过程涉及元素的创建，拷贝或移动，以及可能的析构操作。 emplace_back是直接在容器尾部创建元素，省去了拷贝或移动元素的过程。它接受构造函数的参数，并在容器内存中直接构造对象，从而避免了额外的拷贝和移动操作。\n红黑树和平衡二叉树 AVL是严格的平衡二叉树，所有节点必须满足左右子树的差绝对值不超过1，AVL树时候用于插入与删除的次数较少，查找多 红黑树是一个弱平衡二叉树，它确保没有一条路径会比其他路径长出两倍，对于搜索，插入删除等操作我们用红黑树\n","date":"2023-10-17T17:34:23+08:00","image":"https://ydmy71.github.io/hugo-whw/p/sjjgysf/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_hu7271776233868872057.jpg","permalink":"https://ydmy71.github.io/hugo-whw/p/sjjgysf/","title":"数据结构与算法"},{"content":"Linux Linux指令 输出重定向\n覆盖输出 会覆盖原文件内容\n追加输出 不会覆盖原文件内容 在原内容末尾继续添加\n管道 指令1 | 指令2 指令1的输出是指令2的输入\nVim三种模式 命令模式 编辑模式 末行模式 权限 chmod 数字形式 r：4 w：2x:1-：0 切换用户 su sudo\n查看端口占用情况 netstat -t显示TCP连接信息 -u为UDP -l是仅显示监听状态的端口 ss 和netstat差不多\n系统资源 df指令 df-h 查看文件系统磁盘使用情况统计 free -m 以mb为单位查看内存使用情况 ps 查看进程运作情况 ps-ef | grep 进程号 kill 杀死进程 9 强制删除 top 动态查看进程变化 suspend 终止进程\nGCC GCC是linux系统下最常用的C/C++的编译器 分布编译\n预处理 gcc -E .c -o .i 得到预处理文件\n编译 gcc -s . i 得到汇编文件\n汇编 gcc -c .s 得到机器码文件\n链接 gcc .o\n同步，异步，阻塞，非阻塞 如果立刻去指向该函数，称为同步 如果没有去执行该函数，而是将执行此函数的时机安排在未来的某个时机，然后马上继续执行刚才的代码块，叫做异步 当执行函数时，直至获得完整的资源之前，都暂停执行当前的代码块，这称为阻塞 当执行此函数时，立即获得瞬时的结果，然后马上继续执行当前的代码块。如果获得的瞬时资源不是完整的资源，之后周期性发送类似的请求，直至获得完整的资源，这称为非阻塞。\n软连接和硬链接 硬链接是多个目录项中的索引节点指向一个文件，指向同一个inode，但是indoe不可能跨文件系统，每个文件系统都有各自的indoe数据结构和列表，所以硬链接是不可以跨文件系统。 软连接相当于重新创建一个文件，这个文件有独立的inode，但是这个文件的内容是另外一个文件的路径，所以软连接是可以跨文件系统的，\n静态库与动态库的区别 可执行文件的大小 静态库的大小比动态库的大小大的多 是因为静态库从二进制文件中拷贝了一份 而动态库只是复制了一些重定位和符号表信息\n扩展性与兼容性 如果静态库中函数改变了 可执行文件必须重写编译 而动态库不用 直接编译即可\n加载速度的话 静态库更快 他和可执行文件在一起 而动态库加载或运行时链接\nGDB break/b 数字或者函数 含义时在第几行设置断点 r 运行 n 下一条指令 会越过函数 s 下一条指令 会进入函数\nLinux 系统编程 32位的CPU一次可以处理4个字节 64位CPU可以处理8个字节\n内核 它是操作系统的核心，可以控制硬件 比如 cpu 内存 硬盘，内核作为引用连接硬件设备的桥梁，应用程序只需关心与内核交互，不用关心硬件的细节。\n进程与线程的区别和联系 进程时操作系统进行资源分配调度的基本单元 线程相当于是进程的子任务 他是cpu分配和调度的基本单元 一个进程可以有多个线程 但线程只能属于一个进程 进程管理开销很大 这是因为他需要系统给他分配资源 销毁时也会需要回收 但线程管理开销很小 然后进程之间不会相互影响 如果一个进程内的线程崩溃 则该进程也崩溃 Linux查看动态日志 tail -f Linux理论上可以创建多少个进程 32768 pid\n协程 协程也叫微线程，协程就是子程序在执行时终端并专区执行别的子程序，在适当的时候又返回来执行。 这种子程序间的跳转不是函数调用，也不是多线程执行，所以省去了线程切换的开销，效率很高。并且不需要多线程间锁机制，不会发生变量写冲突。\n进程写文件过程中，写一半崩溃了，已写入的数据会丢失吗？ 不会，page cache的本质是Linux内核管理的内存区域， page cache由多个page构成 page在操作系统了为4kb大小，\n操作系统的内存管理 操作系统内存管理包括物理内存和虚拟内存管理 物理内存管理包括交换与覆盖，分页管理，分段管理。和段页式管理 虚拟内存管理包括虚拟内存的概念，页面置换算法，页面分配策略等 内存分段：程序是由若干个逻辑分段组成的，如可由代码分段，数据分段，栈断，堆段组成。不同的段是有不同属性的，所以就用分段的形式把这些段分离出来。\n内存分页：分页就是把整个虚拟和物理内存空间切成一段段固定尺寸的大小，我们叫做页 通过页表来映射物理虚拟地址 而进程访问的虚拟地址在页表查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存，更新进程页表，最后返回用户空间，恢复进程的运行。\n段页式内存管理 实现的方式：先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，在划分固定大小的页。 地址结构就由段号，段内页号和页内位移三部分组成。 要想得到物理地址 第一访问段表，得到页表起始地址 第二次访问页表，得到物理页号 第三次将物理页号与页内位移组合，得到物理地址。\n死锁产生的必要条件 互斥，一个资源只能被一个进程使用 占有并请求 一个进程因请求资源而阻塞时 不可剥夺 进程已获得的资源，在未使用完之前，不能强行剥夺 循环等待 若进程之间形成一种头尾相接的循环等待资源关系。 产生死锁的原因主要是 因为系统资源不足 进程运行推进的顺序不合适 资源分配不当等 解决办法 重新启动：代价大，在此之前所有进程已完成的计算工作都没了。 终止进程，终于参与死锁的进程并回收它们所占资源。 一次性全部终止； 逐步终止 剥夺资源 剥夺死锁进程所占有的全部或者部分资源 进程回退 让参与死锁的进程回退到以前没有发生死锁的某个点处\n写时拷贝 就是等到修改数据时才真正分配内存空间，这是对程序性能的优化，可以延迟甚至是避免内存拷贝，目的就是为了避免不必要的内存拷贝。也是用引用计数来实现的，会在开辟的空间中多维护四个字节的空间来存储引用计数，多开辟一个加1，释放减一，直到为0\n什么时候用到多进程，什么时候用到多线程 频繁修改，需要频繁创建和销毁的优先使用多线程 计算量 需要大量计算优先用多线程 因为要小号大量CPU资源且切换频繁 相关性：任务相关性强的用多线程 反之多进程，因为线程之间的数据共享和同步比较简单 多分布 可能要扩展到多机分布的用多进程，多核分布的用多线程 同一个进程内的线程会共享什么资源 该进程的地址空间 全局变量 堆空间 线程的栈空间是自己独有的 原子操作 就是要么全部成功，要不都失败，不能出现中间状态 多线程是如何同步的\n互斥锁，读写锁，自旋锁，条件变量 互斥锁 是一种阻塞锁，当某个线程持有锁，其他试图获取该锁的线程被阻塞。无法获取锁时，会被操作系统挂起并进入休眠状态，不再消耗CPU资源，操作系统会进行上下文切换，当线程在等待时会释放CPU资源。 使用场景是，锁被占用时间较长的情况，适合用于保护共享资源访问时间较长或线程竞争激烈的情况\n自旋锁 自旋锁是一种非阻塞锁，当线程尝试获取一个被其他线程持有的自旋锁时，该线程会进入忙等待状态，而不是被挂起。所以他持续的消耗CPU资源，不会发生上下文切换。他通常有一个参数来限制最大尝试次数。 使用场景是，锁被占用时间较短的情况，用于保护共享资源访问时间较短且线程竞争不激励的情况\n乐观锁和悲观锁 悲观锁就是，认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以在访问共享资源前，先要上锁 乐观锁就是，先修改完共享资源，在验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。\n什么是上下文切换 是一种将CPU资源从一个进程分配给另一个进程的机制，并发，当一个进程在执行时，CPU的所有寄存器中的值，进程打开的文件，内存信息等。 进程的上下文切换不仅包含了虚拟内存，栈，全局变量等用户空间的资源，还包括了内核堆栈，寄存器等内核空间的资源。 进程切换： 当内核需要切换到另一个进程时，它需要保存当前进程的 所有状态， 即保存当前进程的上下文，以便在再次执行该进程时，能够必得到切换时的状态执行下去。\n进程调度算法 非抢占式：当进程正在运行时，他就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把CPU让给其他线程。 抢占式：进程在运行是，可以被打断，使其把CPU让给其他进程，抢占的原则有三种，时间片原则，优先权原则，短作业原则。\n先来先服务调度算法 是一种非抢占的先来先服务算法 ，每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。 适用于CPU繁忙型作业的系统，而不适用于I/O繁忙型作业的系统。\n最短作业优先调度算法 会优先选择运行时间最短的进程来运行，对长作业不利，有很多短作业，会给长作业排到很后面，导致不被运行。\n高响应比优先调度算法 主要是权衡了短作业和长作业。 每次进行进程调度时，先计算响应比优先级，然后把响应比优先级最高的进程投入运行。\n时间片轮转调度算法 每个进程被分配一个时间段，称为时间片，即允许该进程在该时间段中运行。 如果时间片用完，进程还在运行的化，那么会将此进程从CPU释放出来，并把CPU分配另外一个进程 如果进程在时间片结束之前阻塞或结束，直接切换CPU 时间片太短会导致CPU效率变慢 太长又会导致短作业进程响应时间变长。\n最高优先级调度算法 从就绪队列中选择最高优先级的进程先运行，称为最高优先级调度算法。 进程的优先级可以分为，静态和动态优先级 静态：创建进程，已经确定优先级，不会改变 动态：根据进程的动态变化调整优先级 随着时间的推移郑家等待进程的优先级 非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，在选择优先级高的进程 抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行\n多级反馈队列调度算法 多级：表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。 反馈：表示如果有新的进程加入优先级高的队列时，立刻停止当前正运行的进程，转而去运行优先级高的队列。\n内存页面置换算法 当CPU访问的页面不在物理内存时，就会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。 页面置换算法的功能是，当出现缺页异常，需要调入新页面而内存已满时，选择被置换的物理页面。\n最佳页面置换算法 发生缺页时，选择最长时间没有被访问的页面进行置换 先进先出置换算法 选择在内存驻留时间很长的页面进行置换 最近最久未使用的置换算法 选择最长时间没有被访问的页面进行置换 最不常用算法 当发生缺页终端时，选择访问次数最少的那个页面，并将其淘汰 加个计数器，一个页面被访问时，加一 发生缺页中断时，淘汰最小计数器那个页面。\n磁盘调度算法 先来先服务： 先到来的请求，先被服务\n最短寻道时间优先： 优先选择从当前磁头位置所需寻道时间最短的请求\n扫描算法： 磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向。\nPCB PCB就是进程控制块，是操作系统中的一种数据结构，用于表示进程的状态，操作系统通过PCB对进程进行管理。存放的是进程标识符，处理机状态，进程调度信息，进程控制信息。进程控制信息，是通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列。\n虚拟内存 虚拟内存是一种管理内存的方式，一个进程通常会有4G的虚拟内存空间，它的地址都是逻辑地址，在每次访问的时候都需要映射成物理地址，操作系统用内存分段和内存分页来进行管理虚拟地址和物理地址的映射关系。\n虚拟内存的实现方式 如果采用连续分配方式时，会使得一部分内存空间都处于暂时或永久的空闲状态，造成内存资源的严重浪费。因此虚拟内存需要建立在离散分配的内存管理方式的基础上，有三种方式。 请求分页存储管理 请求分段存储管理 请求段页式存储管理\n操作系统中的时钟是什么 时钟也被称为定时器，防止一个进程长期占用CPU时间等其他功能。\nMakefile 在makefile里，时间戳是指在进行编译时，通过比较文件的时间戳来确定是否需要重新生成目标文件。时间戳是实现增量编译的核心原理，它能够有效避免不必要的重复编译，提高编译效率\n时间戳 时间戳是指文件最后的修改时间，可以使用stat命令来查看文件的时间戳信息，利用时间戳来判断文件是否发生了变化，从而确定是否需要重新编译相关的文件\n孤儿进程 父进程先于子进程结束，则子进程成为孤儿进程 然后变为孤儿进程后会有一个专门回收的init作为他的父进程\n僵尸进程 进程终止 但是父进程未回收子进程 子进程残留资源(PCB)存放在内核中 父进程没有调用wait或者waitpid， 可以杀死父进程 让init回收\n进程间通信一共有6种方式 管道 匿名管道 pipe 只能单向通信 要想双方通信的话需要建立两个管道 必须有亲缘关系 所谓的管道，就是内核里面的一串缓冲区\n命名管道 fifo 它可以在不相关的进程间也能相互通信。 管道的写入数据都是缓存在内核种，另一个进程读取数据时自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持lseek文件定位操作\n不同设备及其间的进程通信 消息队列 消息队列就是一个保存在内核中的消息链表，是一系列保存在内核中消息的列表 ，具有特定的格式以及特定的消息类型 可以自定义优先级。 消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统。消息队列会一直存在，而前面提到的匿名管道的生命周期，是随着进程的创建而简历，随进程的结束而销毁。 消息队列不适合比较大数据的传输 消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销\n共享内存 就是拿出一块虚拟地址空间来，映射到相同的物理内存中，没有用户态与内核态之间的消息拷贝过程。 这样这个进程写入的东西，另外一个进程立马就能看到，不需要拷贝来拷贝去，大大提高了进程间通信的速度。 但是如果多个进程同时修改同一个共享内存，很有可能冲突了。\n信号量 信号量可以看做是一个计数器 ，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。他可以用来控制多个进程对资源共享的访问 信号量只有两种操作等待和方式 等待P 就是将其值减一如果减完之后信号量小于0表示资源已经被占用，进程需阻塞等待；发送 V就是将值加一或者将进程回复运行P操作就是在进入共享资源之前，V操作是用在离开共享资源之后\n生产者-消费者问题 生产者生成数据后，放到一个缓冲区中 消费者从缓冲区取出数据处理 任何时刻，只能有一个生产者或者消费者可以访问缓冲区 线程同步\u0026mdash;-建立线程执行的顺序\n读写锁 读取资源时用读锁 修改资源时用写锁 工作原理 没有线程持有写锁时 所有线程都可以一起持有读锁 有线程持有写锁时 所有的读锁和写锁都会阻塞\n条件变量 条件变量简单的说，就是休眠当前任务，然后当需要的条件满足的时候，再次唤醒休眠的任务。 通常来说，条件变量是和互斥锁一起使用的，也就是任务一因为在当前的任务中无法完成需要的条件，只能挂起当前任务，然后通过任务二来完成这个条件（通常就是操作线程之间共享的资源），当任务二完成条件后，会发送信号给休眠的任务一，休眠的任务一被唤醒然后向下执行。\n","date":"2023-10-11T17:34:23+08:00","image":"https://ydmy71.github.io/hugo-whw/p/linux/linux_hu9111044435830269880.jpg","permalink":"https://ydmy71.github.io/hugo-whw/p/linux/","title":"Linux"},{"content":"C++知识点 C语言与C++的区别 C语言没有bool类型 C++有 C++可以重载和c没有\n这是因为C++的编译器在编译的时候会带着函数参数的类型 C语言不会 C++是面向对象编程 C是面向过程\nC++ 变量检测增强 例如 在全局 定义一个变量 为 int a； 然后还在全局对他初始化 int a=4；这时会报错 但C不会\n默认返回值不同 在c++中若函数没有返回值 则必须指定为void c没有的话默认为int\nC++有缺省参数 c没有\nC语言中作用域只有两个：局部，全局。C++中则是有：局部作用域，类作用域，名字空间作用域三种。\n菱形继承 类A,类B，类C都继承A，然后类D继承自类和类C，\n会产生数据冗余 类A有一些数据成员，类B和类C继承于A，类B和类C都会有一份自类A的数据副本，当类D继承自类B和类C时，类D实际会有两份来自类A的数据副本，造成数据冗余。\n二义性 当类 D 中调用一个在类 A 中定义的方法时，由于类 D 有两条通过类 B 和类 C 到达类 A 的继承路径，编译器无法确定应该使用哪一条路径上的方法，从而导致二义性问题。\n可以通过虚继承来解决菱形继承 用类B和类C以虚继承的方式继承类A时，类D只会有一份来自类A的数据副本。\nmalloc是如何分配内存的 1.通过brk系统调用从堆分配内存\n2.通过mmap系统调用在文件映射区域分配内存\nmalloc分配的是虚拟内存\n他会预分配更大的空间作为内存池\nmalloc通过brk方式申请的内存，free释放的时候，并不会把内存归还给操作系统，而是缓存在malloc的内存池中\nmalloc通过mmap方式申请的内存，free释放内存的时候，会把内存归还给操作系统，内存得到真正的释放。\nvolatile关键字 提醒编译器他后面所定义的变量随时都有可能被改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值\nC++将引用作为返回值的好处和应该遵守的规则 减少内存开销 提高效率 支持链式操作 注意不能返回局部变量的引用 union和struct的区别 struct 各成员拥有自己的内存，各自使用互不干涉，同时存在遵循内存对齐原则，一个struct变量总长度等于所有成员的长度之和\nunion 各成员共用一块内存空间，并且同时只有一个成员可以得到这块内存的使用权，各变量共用一个内存首地址，联合体比结构体更节约内存，一个union变量的总长度至少能容纳最大的成员变量，而且要满足是所有成员变量类型大小的整数倍。 在赋值的时候，对于union的不同成员赋值，将会对其他成员进行重写，原来成员的值就不存在了，而对于struct的不同成员赋值是互不影响的。\n四种强制类型转换 static_cast 用于将一种数据类型强制转换为另一种数据类型\nconst_cast 用于强制去掉不能被修改的常数特性，但需要特别主义的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。\nreinterpret_cast 改变指针或引用的类型，指针或引用转换为一个足够长度的整形，将整形转换为指针或引用类型\ndynamic_cast 将基类的指针或引用安全地转换成派生类的指针或引用，并用派生类的指针或引用调用非虚函数。如果是基类指针或引用调用的是虚函数无需转换就能在运行时调用派生类的虚函数\ndynamic_cast 的实现原理涉及到一个名为 \u0026ldquo;vtable\u0026rdquo; 的虚函数表和一个名为 \u0026ldquo;type_info\u0026rdquo; 的运行时类型信息 (RTTI) 系统。\n迭代器失效 迭代器：是一个遍历各种容器内元素的访问。 它的底层是一个指针 类模板 迭代器失效：就是迭代器底层对应指针所指向的空间被销毁了，而使用一块已经被释放的空间，造成的后果是程序崩溃。 可能会引起的扩容操作都有可能导致迭代器失效，push_back什么的\nthis指针 this指针存在于类成员函数中，指向类对象的指针。this是一个关键字，同时也是一个指针常量。 成员函数调用时，传递了一个隐含的参数指向函数所在类对象的地址。\nthis在成员在成员函数的开始执行前构造，在成员的执行结束后清除。\n悬空指针是指向被释放内存的指针，而野指针是不确定其具体指向的指针\n用户态与内核态 内核态控制的是内核空间的资源管理，用户态访问的是用户空间内的资源 指令的划分 特权不同 用户态\u0026mdash;\u0026gt;内核态：唯一途径是通过中断、异常、陷入机制（访管指令） 内核态\u0026mdash;\u0026gt;用户态：设置程序状态字PSW\n于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的 处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。 线程切换只能在内核态完成，如果当前用户处于用户态，则必然引起用户态与内核态的切换，线程的调度是在内核态运行的，而线程中的代码是在用户态运行。 拷贝构造为什么参数必须传引用 原文链接：https://blog.csdn.net/xiao23597/article/details/131041511\n初始化参数列表有什么特点 只能在构造函数中使用\n初始化参数列表的初始化顺序和成员变量的顺序一致\n常量和引用在初始化参数列表中初始化\n初始化参数列表可以调用成员对象的构造函数\n当父类没有默认构造函数时，可以利用初始化参数列表调用父类的构造函数\n什么时候调用拷贝构造 用已经存在的对象初始化新的对象的时候\n当对象以值的形式作为函数的参数或返回值时\ndelete为什么先调用析构函数在调用free\n因为先调用free的话，会导致内存泄漏，free直接释放对象的内存了，并没有释放对象所指向的内存\n指针与引用 原文链接：https://blog.csdn.net/weixin_45805339/article/details/128205810\n引用与所引用的变量共用同一块内存空间\n函数指针 int（*p）（int,int）他可以接收add（int a，int b） p=add 函数的名字就是地址 { return a+b；}\nC++空类大小为什么为1 为了实现每个实例在内存中都有一个独一无二的地址，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址，所以空类所占的内存大小是1个字节。\nstrcpy，sprinty，memcpy的区别 1.操作对象不同 strcpy的操作对象均为字符串 memcpy的两个对象是两个可以任意可操作的内存地址，不限于数据类型。\n效率不同 memcpy最快，strcpy慢\n实现功能不同 strcpy主要实现字符串变量间的拷贝 sprintf主要实现其他数据类型格式到字符串的转化 memcpy主要是内存块间的拷贝\n拷贝构造函数调用时机 用已经存在的对象去初始化新对象\n作为函数参数和函数返回值\n如何只在堆区申请对象\n将析构函数私有化，编译器会检查析构函数是否可以被调用 栈区申请内存用alloca()\n在栈区的话将new和delete重载为私有化\nconst const修饰变量时表示变量不可以修改，但是可以通过指针来修改\nconst修饰函数时，表示为常函数，常函数内的this指针是const * const this 所以常函数不能修改成员变量，也不能调用非常函数，这些是因为他们的this指针不匹配\nconst他作为函数的返回值时，可以防止被修改。\n非常函数只能调用常函数，常函数可以调用非常函数也可以调用常函数\n常函数和非常函数是重载关系\nC++类对象的初始化顺序 基类初始化，成员类对象初始化，自身构造函数初始化\n常量指针 const int p 声明一个指向常量整数的指针，常量指针，指针p可以指向不同的内存地址，但所指向的整数不能通过p来修改。\nconst int a = 10;\nconst int b = 20;\nconst int p = \u0026amp;a;\n// *p = 15; // 错误，不能通过指针修改所指向的常量整数\np = \u0026amp;b; // 合法，可以改变指针指向的地址\n指针常量\nint * const p 指针常量是指针本身是常量，即指针一旦初始化指向一个地址后，就不能再指向其他地址，但可以通过该指针修改所指向对象的值。\nint c = 30;\nint d = 40;\nint * const p = \u0026amp;c;\n*p = 35; // 合法，可以通过指针修改所指向的值\n// p = \u0026amp;d; // 错误，不能改变指针\nStatic static修饰全局变量 如果想在头文件中定义全局变量，需要定义为静态全局变量，会防止重定义问题\nstatic修饰局部变量 只作用在局部作用域，只会被初始化一次，不会随着函数的结束而被释放。\nstatic修饰成员变量 静态成员变量在编译期间初始化\n公有的静态成员变量可以通过类名：：和对象名直接访问 存放在静态区\n静态成员变量在继承关系中父类和子类共享 必须在类外初始化，因为静态成员变量是属于类的，不是属于类的任何特定对象，这意味着无论创建了多少个类的实例，静态成员变量都只有一个副本，因此，他需要在类的外部初始化，以确保这个变量的唯一性。\nstatic修饰成员函数时 静态成员函数没有this指针，因此静态成员函数不能访问非静态成员变量 也不能调用非静态成员函数。\n抽象类为什么不能创建对象 这是因为纯虚函数在虚函数表里存放的地址为0\n友元函数和友元类 通过友元，一个普通函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元正确的使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性。\n如何用代码判断大小端存储？ 大端 字数据的高字节存储在低地址中\n小端 字数据的低字节存储在低地址中\n强制类型转换 int转为char 只会留下低地址的地方\n巧用联合体\n如何在类外访问私有成员 通过公有方法访问，使用友元函数或友元类，使用指针强制转换reinterpret_cast 面向过程语言 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。\n缺点：没有面向对象易维护、易复用、易扩展\n面向对象语言 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 在C++的面试中，面向对象编程（OOP）的概念和应用是经常被提及的话题。为了成功应对这类面试，你需要对OOP的基本原理、特性以及它们在C++中的实现方式有深入的理解。以下是一些常见的C++面向对象面试问题及其回答策略： 回答：面向对象编程是一种编程范式，它将现实世界中的事物抽象为对象，并使用类来定义这些对象的属性和行为。OOP的主要特性包括封装、继承和多态。通过OOP，我们可以创建模块化、可重用和可维护的代码。\n封装：封装是隐藏对象的属性和实现细节，仅对外提供公共接口的过程。这有助于保护数据的完整性和安全性，同时也提高了代码的可维护性。 继承：继承允许我们创建一个新的类（子类或派生类），它继承了一个或多个已存在的类（父类或基类）的属性和方法。这使得代码重用成为可能，并有助于建立类之间的层次结构。 多态：多态是面向对象编程的一个重要特性，它允许我们使用父类类型的引用或指针来调用子类的方法。这使得我们可以在运行时动态地确定要调用的方法，从而实现更灵活和可扩展的代码。 虚函数 多态 多态分静态多态和动态多态 静态多态是在编译期间产生的多态 而动态多态是在运行期间确定的多态 静态多态包含： 函数重载 运算符重载 函数模板\n动态多态包括： 父类指针或引用指向子类对象 并通过指针或引用调用重写函数\n动态多态调用过程 首先会通过父类指针或引用访问到子类对象中的虚表指针，然后通过虚表指针找到虚函数表 通过虚函数表存放的虚函数地址去调用虚函数\n虚函数表 一个类只有一个 在编译阶段被构造 所有对象共享同一个虚函数表\n虚函数表指针 当类中存在虚函数时，编译器会给类增加一个指针类型的变量 放到虚函数表中 创建对象时就会创建一个虚函数表指针，在构造函数被赋值，\n因为是在构造函数中被复赋值的 所以构造函数不可以为虚函数 析构函数可以是虚函数么？ 可以 如果产生多态的话 一定要设置虚函数否则在编译时，由于编译器会把父类和子类的构造函数统一命名，那么此时析构函数为函数隐藏，如果父类中的析构函数为虚函数，那么将在子类的析构函数中去调用父类的析构函数，以此来避免内存泄漏\n内联函数 提高效率 它可以将函数体直接嵌入到调用处，避免了常规函数 调用时的压栈，跳转等操作，如果程序的执行小于开辟栈帧等操作的时间有必要设置为内联函数\n不能过于复杂 递归或代码太长\n并非总是有效\n堆和栈 从内存角度上看 堆需要手动申请释放内存 在C++中一般用 new delete c中用 malloc free 栈区的对象不需要回收 由操作系统进行回收 栈的申请速度和释放比堆快的多 因为他是由操作系统来操作的 栈的地址是高地址向低地址增长，堆的地址是低地址向高地址增长的\n从数据结构上看 堆分为 最大堆和最小堆 栈 先进后出\nnew malloc new是在堆区申请内存的 如果给类和结构体申请内存的话 会先调用malloc在调用构造函数 利用new创建的数据 返回数据对应的类型的指针\n释放new申请的内存需要时候delete 如果是数组delete[] 当这个类的析构函数没有作用时 也可以使用free释放new申请的堆区空间\nnew和malloc的区别 new 会先执行malloc 在执行构造函数给成员变量赋值 delete 先会执行析构函数 在执行free\nnew 返回值不需要强转 malloc 返回值需要强转\nnew 是运算符 malloc是c语言库函数\nnew 不需要传入具体的字节个数 malloc 需要传具体字节个数\nnew 会先执行malloc 在执行 构造函数给成员变量赋值 malloc 只分配堆区\nnew 申请失败会抛出异常 malloc会返回空\nnew可以重载因为是运算符\nfinal关键字 修饰虚函数，可以阻止子类重写父类这个函数。修饰类的话，表示不允许被继承\n移动语义 移动语义可以通过浅拷贝从一个对象转移到另一个对象这样就能减少不必要的临时对象的创建，拷贝以及销毁，大幅度提高性能，正常用对象初始化对象时会调用拷贝构造，如果这个对象占的堆区内存很大，就可以用右值引用进行性能优化。\n深拷贝浅拷贝 浅拷贝（Shallow Copy） 是指在拷贝对象时，只是复制了对象中的成员变量的值的引用或指针。浅拷贝后的对象和原对象共享一份数据，修改一个对象可能会影响另一个对象。\n深拷贝（Deep Copy） 是指在拷贝对象时，会创建一个新的独立的对象，并复制原对象中的所有成员变量的值。深拷贝后的对象和原对象是完全独立的，修改一个对象不会影响另一个对象。\nauto auto 让编译器通过初始值来进行类型推演，从而获得定义变量的类型，所以说auto定义的变量必须由初始值。\ndecltype 它的作用是选择并返回操作数的数据类型，在此过程中，编译器只是分析表达式并得到它的类型，去不进行实际的计算表达式的值。\nLambda 相当于一个内嵌的匿名函数，用于替换独立函数或者函数对象。\n返回值，编译器会根据return语句自动推导返回值类型，但是需要主义的是lambda表达式不能通过列表初始化自动推导返回值类型，像vector，list这种。\nsizeof捕获列表：如果lambda捕获了一些外部变量，它的大小将包含这些捕获变量的大小，每个捕获的变量都会在lambda的内部定义一个数据成员\n状态：如果lambda没有捕获任何变量，则其大小通常是固定的，1字节。因为编译器需要给每个lambda表达式生成一个独特的类。\n智能指针 智能指针的底层实现原理主要依赖于引用计数和RAII（‌资源获取即初始化）‌原则。\nRALL：是C++语言的一种管理资源、避免资源泄漏的惯用法，利用栈对象自动销毁的特点来实现，这一概念最早由Bjarne Stroustrup提出。因此，我们可以通过构造函数获取资源，通过析构函数释放资源。‌\n智能指针的主要目的是解决原始指针使用中的内存管理问题，‌如内存泄漏和悬挂指针等。‌智能指针的实现通常涉及到引用计数的机制，‌当智能指针指向的对象不再被使用时，‌引用计数会减少，‌当引用计数达到零时，‌智能指针会自动释放所指向的对象，‌从而避免内存泄漏。‌此外，‌智能指针还可以提供对对象生命周期的更精细控制，‌例如在需要时延迟对象的销毁或共享对象的所有权等 头文件是\nshared_ptr 使用引用计数的方式来管理内存。多个shared_ptr可以指向同一个对象，当最后一个shared_ptr被销毁时，对象才会被释放。适用于多个对象需要共享同一个资源的场景，比如在多个函数之间传递一个对象，并且需要保证在所有使用该对象的地方都不再需要时才释放资源。\nunique_ptr 直接防止拷贝的方式解决智能指针的拷贝问题，简单而又粗暴，防止智能指针对象拷贝，保证资源不会被多次释放。 可以通过move函数转移给其他的unique_ptr， unique_ptr是独占式的智能指针，它保证在任何时刻只有一个unique_ptr指向一个对象，当unique_ptr被销毁时，它所指向的对象也会被自动释放。适用于需要独占资源的场景，比如在函数内部创建一个对象并返回给调用者时，可以使用unique_ptr来确保资源的正确释放。\nweak_ptr expired() 它是来判断观测的资源是否被释放 lock 获取管理所监测资源的share_ptr对象 reset 置零 其他减一 std::weak_ptr是一种弱引用的智能指针，它不会增加对象的引用计数，主要用于解决std::shared_ptr可能出现的循环引用问题。当需要观察一个由std::shared_ptr管理的对象，但又不想影响对象的生命周期时，可以使用std::weak_ptr。\n","date":"2023-09-15T17:34:23+08:00","image":"https://ydmy71.github.io/hugo-whw/p/c-/helena-hertz-wWZzXlDpMog-unsplash_hu14171105241149577777.jpg","permalink":"https://ydmy71.github.io/hugo-whw/p/c-/","title":"C++"},{"content":"MySQL char vachar 区别 一、长度不同 1、char类型：char类型的长度是固定的。 2、varchar类型：varchar类型的长度是可变的。 二、效率不同 1、char类型：char类型每次修改的数据长度相同，效率更高。 2、varchar类型：varchar类型每次修改的数据长度不同，效率更低。 Mysql有哪些锁？ 全局锁 加上之后整个数据库只处于只读状态\n表级锁 不会出现死锁，发生锁冲突几率高，并发低。\n行锁 会出现死锁，发生锁冲突几率低，并发高。注意的是，MySQL行锁是通过索引加载的，即是行锁是加在索引响应的行上，若对应SQL语句没有走索引则会走全表扫描，行锁将变为表锁。 表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作\n意向锁： 在使用共享锁或者独占锁之前，需要加上意向锁，意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发送冲突，意向锁之间也不会发生冲突，只会和共享锁和独占锁冲突，意向锁是为了快速判断表里是否有纪录被加锁。\n共享锁 可以被多个线程持有，如果对数据加上共享锁后，则其他线程只能对A再加共享锁，不能加排他，只能读不能修改\n独占锁 该锁一次只能被一个线程所持有，如果线程对数据加上排他锁后，则其他线程不能在对这个数据加任何类型的锁，获得排他锁的线程可读可修改。\nMysql架构了解 首先是连接器，负责和客户端建立连接，获取权限，接下来是查询缓存，若之前查询过，则直接返回结果，但失效太频繁，在更新表后，缓存全没，在8.0后删除了功能，接下来是分析器，对语法进行分析符不符合规范，优化器，对语句进行优化选择索引，最后是执行器，首先判断改表有无执行权限，调用存储引擎提供接口返回给客户端\n索引 索引 他是mysql存储引擎用的一种加快查询速度的数据结构 优点： 可以将随机I/0 改为顺序I/0，提高查询性能，帮助服务器避免排序和临时表 缺点：从空间角度考虑 建立索引需要占用物理空间 从时间上考虑的话 维护索引比较花费时间 常见的索引 有 哈希索引 由哈希表实现 查找特别快 0（1）但是它范围查和顺序查不是很快全文索引 B+树索引 最为有效的索引 是因为它不用扫描全盘 他是按顺序存储的 B+树 他只有叶子节点存数据 非叶子节点存索引 叶子节点构造一个有序的链表 高度更低 io次数更少 索引最好设置为NOT NULL 索引列存在NULL就会导致优化器在做索引选择的时候更加复制，难以优化 NULL值是一个没有意义的值，但是他会占用物理内存，所以会带来存储空间的问题。\nSQL注入攻击 SQL注入是一种常见的网络安全威胁，攻击者通过在用户输入中插入恶意的SQL代码，从而可以执行未经授权的数据库操作。 用一些正则表达式在输入的时候去解决。 设置防火墙等。 MySQL为什么选择B+树来作为索引的数据结构\nMVCC 它是一种用来解决读写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 解决以下问题 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能。 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题。\n解决幻读 针对于快照读 select是通过MVCC方式解决了幻读，首先创建一个Read View 后续的查询语句利用这个Read View,通过这个就可以在undo log版本链找到事务开始时的数据，所以事务过程种每次查询的数据都是一样的。 针对当前读 update insert delete 是通过记录锁和间歇锁解决了幻读。 间歇锁就是表中有个范围（3，5）其他事务无法插入 4这条记录。\nMVCC 在 RC（不可重复读） 和 RR（可重复读） 这种隔离级别下面，产生ReadView的区别? 而对于 RC 级别，其实整个过程几乎一样，唯一不同的是生成 ReadView 的时机，RR 级别只在事务开始时生成一次，之后一直使用该 ReadView。而 RC 级别则在每次 select 时，都会生成一个 ReadView。\nMySQL的在RC和RR模式下的锁 RC没有间隙锁\n聚簇索引 一种数据存储的方式 与数据在一起，非聚簇索引得回表 聚簇索引实际上是一个或多个列的值排序的算法 特点就是数据的顺序和索引的顺序一致 一般情况下主键会默认创建聚簇索引，一张表只允许存在一个聚簇索引\n聚簇索引和非聚簇索引的区别 聚簇索引就是 叶子节点都是数据节点 但是非聚簇索引的叶子节点仍然是索引节点，只不过有对应数据块的指针\n覆盖索引 如果一个索引包含了满足查询语句中字段与条件的数据叫做覆盖索引\n最左前缀原则： 创建 （a,b,c）相当于 a,(a,b),(a,b,c) 所以要把选择性最高的放在前面 用Explain来查询索引是否被使用\nLimit用法 select * from table limit 2，5； 意思是查询出第三行数据包括查5个 ，也就是3-7\n读写分离 读写分离常用代理方式来实现，代理服务器接收到读写请求后，然后转发到哪个服务器，主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作 读写分离性能高的原因在于主从服务器负责各自的读和写，极大程度缓解了锁的争用 从服务器可以用MyISAM，提升查询以及节约系统开销 增加冗余\nMyISAM为什么查询比Innodb快 1）查询时，由于innodb支持事务，所以会有mvvc(多版本并发控制)的一个比较，这个过程会损耗性能。 2）查询时，如果走了索引，而索引又不是主键索引，此时由于innodb是聚簇索引，会有一个回表的过程，即：先去非聚簇索引树（非主键索引树）中查询数据，找到数据对应的key之后，再通过key回表到聚簇索引树，最后找到需要的数据。而myisam是非聚集索引，而且叶子节点存储的是磁盘地址，所以，查询的时候查到的最后结果不是聚簇索引树的key，而是会直接去查询磁盘。 3）锁的一个损耗，innodb锁支持行锁，在检查锁的时候不仅检查表锁，还要看行锁。 三范式 范式是关系数据库设计的一种规范，目的是消除冗余，建立合理的数据库，从而提升数据存储和使用的性能。\n第一范式： 保证每个字段不可分 原子性\n第二范式： 保证 每个字段都完全依赖于主键 不能只依赖于一般分， 唯一性和依赖性\n第三范式： 没有传递依赖 任何非主属性不依赖于其他非主属性\n事务 start transaction 提交事务 commit 保存回滚点 savepoint 回滚事务 rollback[ to 回滚点名] 启用或关闭自动提交模式 set autocommited=1;启用 set autocommited=0 关闭\n四个特性： 原子性 要么全部成功 要么全部失败\n一致性 数据库总会从一个状态转换成另外一个状态\n隔离性 一个事务所做的修改在提交前 堆其他事务是不可见的\n持久性 事务一旦提交 其修改会持久的保存到数据库中，放到缓存池中\n并行事务所带来的问题 脏读： 一个事务读到未提交的数据叫脏读\n不可重复读 在一个事务内读取同一条记录 前后结果不一样\n幻读： 在一个事务内按相同条件多次查询 前后结果集的数量不同就叫做幻读\n隔离级别 未提交读： 没有提交也能被其他事务看到\n提交读 提交后才能被其他事务所看到 可重复读 mysql默认隔离级别 事务在执行期间看到的数据始终与其启动时看到的数据保持一致。这种隔离级别确保同一事务的多个实例在并发读取数据时，会看到同样的数据行\n可串行化 强制事务串行执行 避免幻读问题 每一行数据加锁\n实现隔离级别的方法 加锁 对数据前对其加锁 阻止其他事务对数据进行修改\n快照 读取之前的快照 可重复读可以在读取事务开始的快照去解决不可重复读问题\n什么SQL语句会加行级锁？ 如果要在查询时对记录加行级锁，叫做锁定读 还有update和delete会加行级锁，且锁的类型都是独占锁。\nMysql用长连接有什么好处么？ 在长连接模式下，长连接是指在应用程序与数据库建立一次连接后，保持该连接的状态，直到显示关闭连接， 短链接，即每次数据库操作都建立新的连接并在操作完成后立即关闭连接。\nMySQL日志 undo log：回滚日志，实现了事务中的原子性，主要用于事务回滚和MVCC redo log：重做日志 时innodb引擎生成的日志，实现了事务的持久性，主要用于故障恢复 binlog归档日志：是Server层生成的日志，主要用于数据备份和主从复制 为什么要undo log？ 我们在每次执行事务过程种，都要记录下回滚需要的信息到一个日志里，如果Mysql崩溃后，就不用但系无法回滚到事务之前的数据，我们可以通过这个日志回滚到事务之前的数据。\n为什么需要redo log？ WAL技术指的是，MYSQL的写操作并不是立刻写在磁盘上的，而是先写日志，在合适的时间在写道磁盘上。\nredo log是物理日志，记录了某个数据页做了什么修改，每当执行一个事务就会产生这样的一条或者多条物理日志。 redo log记录了此次事务完成后的数据状态，记录的是更新之后的值 undo log记录了此次事务开始前的数据状态，记录的是更新之前的值 redo log的方式使用了追加操作，所有磁盘操作是顺序写，写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作作是随机写。 为什么需要binlog？ binlog文件是记录了所以数据表结构变更和表数据修改的日志，不会记录查询类的操作，比如SELECT和SHOW操作\nredo log和binlog有什么区别？ binlog是Mysql的Server层实现的日志，所有存储引擎都可以使用。 redo log是Innodb存储引擎实现的日志；\n主从复制 MySQL集群的主从复制过程梳理成三个阶段 写入Binlog：主库写binlog日志，提交事务，并更新本地存储数据 同步binlog：把binog复制到所有从库上，每个从库把binlog写到暂存日志种 回放binlog回放binlog，并更新存储引擎中的数据 首先主库收到客户端提交事务的请求之后，会先写入binlog，在提交事务，更新存储引擎中的数据，事务提交完成后，从库会创建一个专门的I/O线程，来接收binlog日志，再把binlog信息写入relay log的中继日志里，然后从库创建一个用于回放binlog的线程，去读relay log中继日志，然后回访binlog更新存储引擎中的数据，最终实现主从的数据一致性。完成之后，可以只在主库中写数据，读数据用从库，这样即使写请求会锁表或者锁记录，也不会印象读请求的执行。 数据库和缓存如何保证一致性？ 无论是先更新数据库还是在更新缓存，这两个方案都会存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库数据不一致的现象。 引下来先更新数据库还是先删除缓存？ 不更新缓存，而是删除缓存中的数据，然后读取数据时，发现缓存中没了数据之后，在从数据库中读取数据，更新到缓存中。 分为写策略和读策略\n写策略 分为 先更新数据库中的数据 在删除缓存中的数据 是因为缓存的写入通常要远远快于数据库的写入。 先删除缓存中的数据 在更新数据库\n读策略 如果读取的数据有缓存，则直接返回数据 如果读取的数据没有命中缓存，则从数据库读数据，然后将数据写入到缓存，并返回给用户。 如何保证，先更新数据库，在删除缓存这两个操作能执行成功？\n如何保证两个操作都能执行成功？ 消息队列重试机制 引入消息队列，将第二个要操作的数据加入到消息队列，由消费者来操作数据 如果应用删除缓存失败，可以从消息队列中重新读取数据，然后在次删除缓存 如果删除缓存成功，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。\n分库分表 分库分表是一种数据库设计和管理中的一种策略，主要解决随着数据量和并发访问量的增加而带来的性能，和扩展性问题。\n分库： 将数据按照某种规则，分散到多个独立的数据库中，\n分表： 将一个大表的数据按照某种规则，分散到多个小表中，每个小表称为一个分片或分表 分库分表通过将数据，按照某种策略分配到多个数据库节点，或表中，提高了查询和写入性能，增强系统的可扩展性和容错能力。\n分为水平拆分和垂直拆分 垂直拆分，就是把字段分开 水平拆分，就是把记录分开\n","date":"2023-09-15T17:34:23+08:00","image":"https://ydmy71.github.io/hugo-whw/p/mysql/oy_hu6500264349742603922.jpg","permalink":"https://ydmy71.github.io/hugo-whw/p/mysql/","title":"MySQL"},{"content":"","date":"2023-05-18T17:34:23+08:00","image":"https://ydmy71.github.io/hugo-whw/p/network/newwork_hu9755546372781295767.jpg","permalink":"https://ydmy71.github.io/hugo-whw/p/network/","title":"网络协议"}]