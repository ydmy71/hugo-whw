<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="TCP TCP连接 什么是TCP？ TCP是面向连接的、可靠的、基于字节流的传输协议。\n面向连接：一定是1对1 才能连接，不能像UDP协议可以一台主机同时向多个主机发送消息，也就是一对多是无法做到的 可靠的：无论网络链路中出现了什么样的变化，TCP都可以保证一个报文一定能够到达接收端。 字节流：就是可以说当在传输层发消息的时候，一个消息可能会被分割成多个tcp报文进行转发给网络层，我们不能认为一个tcp报文就是一个消息，所以tcp是面向字节流的 （由于是面向字节流 ，就有可能会出现粘包的问题。） 如何唯一确定TCP连接？ 通过四元组就是（源地址、源端口、目标地址、目标端口）\n源地址存在IP协议的头部中，作用是通过IP协议发送报文给对方主机\n端口号存在TCP的头部中，作用是通过TCP协议应该把报文给那个端口\n通过这四个组合可以确定唯一的TCP连接\n">
<title>网络协议</title>

<link rel='canonical' href='https://ydmy71.github.io/hugo-whw/p/network/'>

<link rel="stylesheet" href="/hugo-whw/scss/style.min.0304c6baf04e01a8fe70693791cb744d56a3578a3120a8796cefc66825aa39c7.css"><meta property='og:title' content="网络协议">
<meta property='og:description' content="TCP TCP连接 什么是TCP？ TCP是面向连接的、可靠的、基于字节流的传输协议。\n面向连接：一定是1对1 才能连接，不能像UDP协议可以一台主机同时向多个主机发送消息，也就是一对多是无法做到的 可靠的：无论网络链路中出现了什么样的变化，TCP都可以保证一个报文一定能够到达接收端。 字节流：就是可以说当在传输层发消息的时候，一个消息可能会被分割成多个tcp报文进行转发给网络层，我们不能认为一个tcp报文就是一个消息，所以tcp是面向字节流的 （由于是面向字节流 ，就有可能会出现粘包的问题。） 如何唯一确定TCP连接？ 通过四元组就是（源地址、源端口、目标地址、目标端口）\n源地址存在IP协议的头部中，作用是通过IP协议发送报文给对方主机\n端口号存在TCP的头部中，作用是通过TCP协议应该把报文给那个端口\n通过这四个组合可以确定唯一的TCP连接\n">
<meta property='og:url' content='https://ydmy71.github.io/hugo-whw/p/network/'>
<meta property='og:site_name' content='吴宏伟✊'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2023-05-18T17:34:23&#43;08:00'/><meta property='article:modified_time' content='2023-05-18T17:34:23&#43;08:00'/><meta property='og:image' content='https://ydmy71.github.io/hugo-whw/p/network/newwork.jpg' />
<meta name="twitter:title" content="网络协议">
<meta name="twitter:description" content="TCP TCP连接 什么是TCP？ TCP是面向连接的、可靠的、基于字节流的传输协议。\n面向连接：一定是1对1 才能连接，不能像UDP协议可以一台主机同时向多个主机发送消息，也就是一对多是无法做到的 可靠的：无论网络链路中出现了什么样的变化，TCP都可以保证一个报文一定能够到达接收端。 字节流：就是可以说当在传输层发消息的时候，一个消息可能会被分割成多个tcp报文进行转发给网络层，我们不能认为一个tcp报文就是一个消息，所以tcp是面向字节流的 （由于是面向字节流 ，就有可能会出现粘包的问题。） 如何唯一确定TCP连接？ 通过四元组就是（源地址、源端口、目标地址、目标端口）\n源地址存在IP协议的头部中，作用是通过IP协议发送报文给对方主机\n端口号存在TCP的头部中，作用是通过TCP协议应该把报文给那个端口\n通过这四个组合可以确定唯一的TCP连接\n"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://ydmy71.github.io/hugo-whw/p/network/newwork.jpg' />
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/hugo-whw/">
                
                    
                    
                    
                        
                        <img src="/hugo-whw/img/avatar_hu7773848017125322119.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🤨</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/hugo-whw">吴宏伟✊</a></h1>
            <h2 class="site-description">欢迎来到我的网站，这里有C&#43;&#43;,MySQL,Linux操作系统,网络等学习资源！😀</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://space.bilibili.com/1645857396?spm_id_from=333.1007.0.0'
                        target="_blank"
                        title="Bilibili"
                        rel="me"
                    >
                        
                        
                            <?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1727786333597" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4238" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M729.32864 373.94944c-9.79456-5.94432-19.06176-6.784-19.14368-6.784l-1.06496-0.0512c-57.20064-3.8656-121.1648-5.83168-190.12608-5.83168l-13.98784 0.00512c-68.95616 0-132.92544 1.96096-190.12096 5.83168l-1.06496 0.0512c-0.08192 0-9.34912 0.83968-19.14368 6.784-15.04768 9.12896-24.27392 25.94816-27.4176 49.9712-10.07104 76.91264-4.38272 173.64992 0.18944 251.392 2.93888 49.96608 33.408 62.45888 85.04832 67.1488 10.78272 0.98816 69.08928 5.86752 159.50848 5.89312v-0.00512c90.4192-0.02048 148.72576-4.90496 159.5136-5.888 51.64032-4.68992 82.10944-17.18272 85.0432-67.1488 4.57728-77.74208 10.26048-174.47936 0.18944-251.392-3.1488-24.02816-12.37504-40.84736-27.42272-49.97632z m-390.9888 172.71808a23.64928 23.64928 0 0 1-31.68768-10.84416 23.68 23.68 0 0 1 10.84416-31.68768c2.03776-1.00352 50.69312-24.72448 110.5408-43.06432a23.68 23.68 0 1 1 13.88032 45.29152c-56.2944 17.24928-103.11168 40.07424-103.5776 40.30464z m268.89728 35.88608c-0.44032 2.23232-11.26912 54.64064-50.93888 54.64064-21.44256 0-36.10112-14.04928-44.98432-26.77248-8.69376 12.70784-22.80448 26.77248-42.65472 26.77248-35.5328 0-50.13504-48.26624-51.68128-53.77024a11.3664 11.3664 0 0 1 21.87776-6.1696c2.74944 9.6512 14.1312 37.20192 29.7984 37.20192 16.37376 0 28.89216-23.64416 31.98464-31.92832a11.37152 11.37152 0 0 1 10.6496-7.38816h0.06144c4.76672 0.03072 9.0112 3.02592 10.62912 7.50592 0.10752 0.28672 11.96544 31.81568 34.31424 31.81568 20.864 0 28.56448-35.95264 28.64128-36.32128a11.34592 11.34592 0 0 1 13.35808-8.93952 11.36128 11.36128 0 0 1 8.94464 13.35296z m110.11584-46.73536a23.68 23.68 0 0 1-31.68256 10.84416c-0.47104-0.2304-47.47264-23.1168-103.57248-40.30976a23.69024 23.69024 0 0 1-15.70816-29.58336 23.66976 23.66976 0 0 1 29.57824-15.70304c59.84768 18.33984 108.49792 42.0608 110.55104 43.06432a23.68 23.68 0 0 1 10.83392 31.68768z" fill="#F16C8D" p-id="4239"></path><path d="M849.92 51.2H174.08c-67.8656 0-122.88 55.0144-122.88 122.88v675.84c0 67.87072 55.0144 122.88 122.88 122.88h675.84c67.87072 0 122.88-55.00928 122.88-122.88V174.08c0-67.86048-55.00928-122.88-122.88-122.88z m-36.60288 627.45088c-2.62656 44.57984-21.82144 78.63296-55.51616 98.48832-25.68192 15.13472-54.17472 19.48672-81.13664 21.9392-32.45568 2.94912-92.71808 6.09792-164.66432 6.1184-71.94112-0.02048-132.20864-3.16416-164.66432-6.1184-26.96192-2.45248-55.45472-6.80448-81.13152-21.9392-33.69472-19.85536-52.8896-53.90336-55.51104-98.4832-4.70528-80.13312-10.5728-179.85536 0.19456-262.10816C221.5424 335.16544 280.99072 311.57248 311.5008 310.37952a2482.64192 2482.64192 0 0 1 81.42336-4.08576c-7.53664-8.53504-19.88096-23.3216-28.81536-38.11328-13.73696-22.73792 8.52992-41.68704 8.52992-41.68704s23.68-20.36736 44.52864 5.21216c15.69792 19.26656 38.37952 55.99744 48.61952 72.95488l53.20704-0.21504c13.2608 0 26.33216 0.07168 39.2192 0.21504 10.24-16.95744 32.9216-53.6832 48.61952-72.95488 20.84352-25.57952 44.52864-5.21216 44.52864-5.21216s22.26176 18.94912 8.5248 41.68704c-8.9344 14.79168-21.27872 29.57824-28.81536 38.11328 28.35968 0.97792 55.56224 2.33984 81.42336 4.08064 30.5152 1.19808 89.9584 24.79104 100.61312 106.17344 10.7776 82.24768 4.9152 181.96992 0.20992 262.10304z" fill="#F16C8D" p-id="4240"></path></svg>
                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://github.com/ydmy71'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/hugo-whw/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/hugo-whw/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/hugo-whw/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/hugo-whw/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/hugo-whw/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#tcp连接">TCP连接</a>
      <ol>
        <li><a href="#什么是tcp">什么是TCP？</a></li>
        <li><a href="#如何唯一确定tcp连接">如何唯一确定TCP连接？</a></li>
        <li><a href="#tcp-和-udp-有什么区别-应用场景是什么">TCP 和 UDP 有什么区别？ 应用场景是什么？</a></li>
        <li><a href="#为什么要进行三次握手不是二次四次">为什么要进行三次握手，不是二次、四次？</a></li>
        <li><a href="#tcp-为什么每次建立连接的序列号都要求不一样呢">TCP 为什么每次建立连接的序列号都要求不一样呢？</a></li>
        <li><a href="#既然ip层会分片为什么tcp层还需要mss呢">既然IP层会分片，为什么TCP层还需要MSS呢？</a></li>
        <li><a href="#tcp和udp可以使用同一个端口么">TCP和UDP可以使用同一个端口么？</a></li>
        <li><a href="#初始序列号isn是如何产生的">初始序列号ISN是如何产生的？</a></li>
        <li><a href="#第一次握手丢失会发生什么">第一次握手丢失会发生什么？</a></li>
        <li><a href="#第二次握手数据丢失会发生什么">第二次握手数据丢失会发生什么？</a></li>
        <li><a href="#第三次握手对视会发生什么">第三次握手对视会发生什么？</a></li>
        <li><a href="#什么是syn攻击如何避免syn攻击">什么是SYN攻击？如何避免SYN攻击？</a></li>
      </ol>
    </li>
    <li><a href="#tcp-连接断开">TCP 连接断开</a>
      <ol>
        <li><a href="#为什么需要四次挥手">为什么需要四次挥手？</a></li>
        <li><a href="#ack报文为什么不会重传">ACK报文为什么不会重传？</a></li>
        <li><a href="#第一次挥手丢失会发生什么">第一次挥手丢失会发生什么？</a></li>
        <li><a href="#第二次挥手丢失会发生什么">第二次挥手丢失会发生什么？</a></li>
        <li><a href="#第三次挥手丢失会发生什么">第三次挥手丢失会发生什么？</a></li>
        <li><a href="#第四次挥手丢失会发生什么">第四次挥手丢失会发生什么？</a></li>
        <li><a href="#为什么tim_wiait-等待时间是2msl">为什么TIM_WIAIT 等待时间是2MSL？</a></li>
        <li><a href="#为什么需要time_wait-状态">为什么需要TIME_WAIT 状态？</a></li>
      </ol>
    </li>
    <li><a href="#tcp重传机制滑动窗口流量控制拥塞控制">TCP重传机制、滑动窗口、流量控制、拥塞控制</a>
      <ol>
        <li><a href="#超时重传">超时重传</a></li>
        <li><a href="#快速重传">快速重传</a></li>
        <li><a href="#sack方法">SACK方法</a></li>
        <li><a href="#duplicate-sack">Duplicate SACK</a></li>
        <li><a href="#滑动窗口">滑动窗口</a></li>
        <li><a href="#流量控制">流量控制</a></li>
        <li><a href="#拥塞控制">拥塞控制</a></li>
      </ol>
    </li>
    <li><a href="#tcp-一些经典的问题">TCP 一些经典的问题</a>
      <ol>
        <li><a href="#如何理解tcp是面向字节流的协议">如何理解TCP是面向字节流的协议？</a></li>
        <li><a href="#已经建立tcp连接再次收到syn会发生什么情况">已经建立TCP连接，再次收到SYN，会发生什么情况？</a></li>
        <li><a href="#如何关闭一个tcp连接">如何关闭一个TCP连接？</a></li>
        <li><a href="#四次挥手中收到乱序的fin会如何处理">四次挥手中收到乱序的FIN会如何处理？</a></li>
        <li><a href="#在time_wait状态下的tcp连接在收到syn报文会发生什么">在TIME_WAIT状态下的TCP连接，在收到SYN报文会发生什么？</a></li>
        <li><a href="#tcp的保活机制">TCP的保活机制</a></li>
        <li><a href="#客户端在拔掉网线之后tcp连接是否发生变化">客户端在拔掉网线之后TCP连接是否发生变化？</a></li>
        <li><a href="#服务器没有listen客户端发起连接会发生什么">服务器没有listen，客户端发起连接会发生什么？</a></li>
        <li><a href="#没有accept-能建立tcp连接么">没有accept， 能建立TCP连接么？</a></li>
        <li><a href="#全连接队列满了会怎么样">全连接队列满了会怎么样？</a></li>
        <li><a href="#tcp四次挥手可以变成三次么">TCP四次挥手，可以变成三次么？</a></li>
        <li><a href="#什么情况下会发生三次挥手">什么情况下会发生三次挥手？</a></li>
        <li><a href="#优雅关闭shutdown-和-暴力关闭close">优雅关闭（shutdown） 和 暴力关闭（close）</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/hugo-whw/p/network/">
                <img src="/hugo-whw/p/network/newwork_hu3608570842526710353.jpg"
                        srcset="/hugo-whw/p/network/newwork_hu3608570842526710353.jpg 800w, /hugo-whw/p/network/newwork_hu13781007873193715027.jpg 1600w"
                        width="800" 
                        height="779" 
                        loading="lazy"
                        alt="Featured image of post 网络协议" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/hugo-whw/categories/http/" >
                HTTP
            </a>
        
            <a href="/hugo-whw/categories/https/" >
                HTTPS
            </a>
        
            <a href="/hugo-whw/categories/tcp/" >
                TCP
            </a>
        
            <a href="/hugo-whw/categories/udp/" >
                UDP
            </a>
        
            <a href="/hugo-whw/categories/ip/" >
                IP
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/hugo-whw/p/network/">网络协议</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">May 18, 2023</time>
            </div>
        

        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="tcp">TCP
</h1><h2 id="tcp连接">TCP连接
</h2><h3 id="什么是tcp">什么是TCP？
</h3><p>TCP是面向连接的、可靠的、基于字节流的传输协议。</p>
<ul>
<li>面向连接：一定是1对1 才能连接，不能像UDP协议可以一台主机同时向多个主机发送消息，也就是一对多是无法做到的</li>
<li>可靠的：无论网络链路中出现了什么样的变化，TCP都可以保证一个报文一定能够到达接收端。</li>
<li>字节流：就是可以说当在传输层发消息的时候，一个消息可能会被分割成多个tcp报文进行转发给网络层，我们不能认为一个tcp报文就是一个消息，所以tcp是面向字节流的 （由于是面向字节流 ，就有可能会出现粘包的问题。）</li>
</ul>
<h3 id="如何唯一确定tcp连接">如何唯一确定TCP连接？
</h3><p>通过四元组就是（源地址、源端口、目标地址、目标端口）<br />
源地址存在IP协议的头部中，作用是通过IP协议发送报文给对方主机<br />
端口号存在TCP的头部中，作用是通过TCP协议应该把报文给那个端口<br />
通过这四个组合可以确定唯一的TCP连接<br /></p>
<h3 id="tcp-和-udp-有什么区别-应用场景是什么">TCP 和 UDP 有什么区别？ 应用场景是什么？
</h3><ul>
<li>连接上的区别<br />
tcp 是面向连接的，传输数据之前要建立连接。<br />
udp是不需要连接，即刻传输数据<br /></li>
<li>服务对象<br />
tcp是一对一的两点服务<br />
udp是支持一对一，一对多，多对多的<br /></li>
<li>可靠性<br />
tcp是可靠性交付，数据可以没有差错，不丢失，不重复，按时到达。<br />
udp不是可靠的，不保证可靠交付数据。<br /></li>
<li>拥塞控制、流量控制<br />
tcp有流量控制和拥塞控制机制，保证数据的传输安全<br />
udp没有这些，即使网络非常拥堵，也不影响udp的传输效率<br /></li>
<li>首部开销<br />
tcp 的首部开销比较大 ，再首部没有选项字段时时20 字节，如果使用了，会变长。<br />
udp 的首部开销时固定的，比价小，只有8 字节<br /></li>
<li>传输方式<br />
tcp是字节流传输，没有边界（有可能导致粘包问题） ，单保证顺序和可靠<br />
udp是一个包一个包发送的，有边界，但是不可靠。<br /></li>
<li>分片不同<br />
tcp的数据大小再超多MSS大小，就会在传输层分片，目标主机收到会在传输层进行组装tcp数据包，如果中途丢失了，只需要传输丢失的部分即可。
MSS = MTU - IP （首部）- TCP（首部） <br />
udp的大小如果超过了MTU（1500字节）大小，就会再IP层分片，目标主机收到会再IP 层组装，再给传输层。<br /></li>
</ul>
<h3 id="为什么要进行三次握手不是二次四次">为什么要进行三次握手，不是二次、四次？
</h3><p>原因有 3 个</p>
<ul>
<li>3次握手可以防止历史连接的建立，导致初始化混乱（主要原因）</li>
<li>同步双方初始序列号</li>
<li>避免资源浪费<br />
防止旧连接的建立导致初始化混乱
我们假设一个情景就是当客户端第一次发起连接的时候，网络阻塞，这个时候客户端没有收到连接请求，客户端重启之后再次发出请求，这个时候旧的请求连接旧会比新的连接先到达，服务器进行回复，如果是两次握手在服务器接收到消息的时候，就已经建立了连接，这个时候服务器回复确认号以及序列号，但是客户端发现这不是我要接收到的序列号，就会发起RST报文，让服务器释放连接，造成了资源浪费，如果是三次握手就不会有这样的情况，因为不会再第一次握手就建立连接。<br />
同步双方的序列号
TCP协议的通信双方，都必须维护一个序列号，序列号是可靠传输的一个关键因素。
它的作用：接收方可以根据序列号取出重复的数据， 可以根据序号接收，可以表示发送出去的数据包那些被接收了，通过ACK报文中的序列号来知道。
二两次握手只能确认一方的序列号。</li>
</ul>
<h3 id="tcp-为什么每次建立连接的序列号都要求不一样呢">TCP 为什么每次建立连接的序列号都要求不一样呢？
</h3><p>如果每次都一样，就大概率会遇到历史报文的序列号，恰好再对方的接收窗口内， 那么就回导致数据错乱，这样如果每次建立连接的序列号都不一样的化，就会很大程度上避免了这样的情况。<br />
但是初始化序列号和 序列号 并不是无线递增的，就会发生回绕的情况， 这就代表这不能完全根据序列号来判断新老数据，为了解决这个问题 ，TCP使用了时间戳， tcp_timestamps ， 他有两个好处，一个就是便于RTT【包的往返时间】的计算，另一个就是防止序列号回绕的问题。<br /></p>
<h3 id="既然ip层会分片为什么tcp层还需要mss呢">既然IP层会分片，为什么TCP层还需要MSS呢？
</h3><p>如果将TCP的整个报文，交给IP层来进行分片，有一个隐患就是当一个IP分片丢失，整个报文的所有分片都要重新上传，因为IP层没有超时重传机制，当有一个分片丢失，接收方就无法再IP层组装一个完整的TCP报文，也就无法发送确认接收的ACK，发送方一直无法接收到接收方的ACK确认，那么发送端就会触发TCP超时重传机制，再次组装重新交给IP层进行发送。这样的效率是不高的，因为数据包当大于MSS就会进行分片，那么也一定小于MTU，也就不需要IP层进行分片了。</p>
<h3 id="tcp和udp可以使用同一个端口么">TCP和UDP可以使用同一个端口么？
</h3><ul>
<li>多个TCP服务进程可以同时绑定同一个端口么？</li>
<li>重启TCP服务进程时，为什么会出现“Address in use” 的报错信息？ 又该怎么避免面？</li>
<li>客户端的端口可以重复使用吗？</li>
<li>客户端TCP来凝结TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立连接么？ <br /></li>
</ul>
<p>可以的，再数据链路层，通过mac地址来寻找局域网中的主机，再网络层中，通过IP地址来寻找网络中相连的主机和路由器。 再传输层中，通过端口号进行寻址，来识别同意计算机中的不同应用程序。 传输层中的两个协议TCP 和 UDP 再内核中式两个完全独立的模块。再IP包头部的协议号字段就能知道是哪个协议，并把它们发给对应的模块进行处理，最后再根据端口号确定送给那个程序。</p>
<h3 id="初始序列号isn是如何产生的">初始序列号ISN是如何产生的？
</h3><p>初始 ISN 时基于时钟的， 每4微秒 +1 ，转一圈要4.55 个小时
RFC793 提出了初始化学列号ISN随机生成算法 ： ISN = M + F（四元组）<br />
M 时一个计时器，每隔 4 微秒+1 <br />
F 是一个Hash 算法， 根据四元组生成一个随机值，保证Hash算法不能被外部轻易推出。<br />
而其，随机数是基于始终计时器进行递增的，随意基本不会出现相同的初始化序列号。</p>
<h3 id="第一次握手丢失会发生什么">第一次握手丢失会发生什么？
</h3><p>客户端想和服务器建立TCP连接，会发送SYN 请求和一个初始化序列号， 如果第一个包丢失，倒置一直没收到服务器的SYN-ACK（第二次握手），就会触发【超时重传】 机制， 重传 SYN报文，而其重传的SYN的序列号都是一样的。 <br />
不同版本的操作系统有不同的超时重传机制， 有点是1 秒 ， 有的是 3 秒，具体时间是内核来控制的。<br />
在客户端没收到服务器的回应就会【超时重传】Linux 中有一个内核参数tcp_syn_retries来控制整个次数，<br />
这个参数可以自定义， 默认值是5 。<br />
一般的超时重传的时间是以2倍变化的，再第五次重传后再等待 32 秒，客户端再次发送请求，还是没有收到ACK确认，客户端就不会再发了，会断开TCP连接。 总耗时就是 1 +2 +4+8 +16 +32  = 63 大概1 分钟左右。</p>
<h3 id="第二次握手数据丢失会发生什么">第二次握手数据丢失会发生什么？
</h3><p>客户端和服务器都会进行【超时重传】 因为客户端会认为自己没发过去，服务器也会觉得自己每发送过去。控制第二次握手的参数是 tcp_synack_retries 由内核决定。剩下的流程和i第一次是一样的。</p>
<h3 id="第三次握手对视会发生什么">第三次握手对视会发生什么？
</h3><p>当服务端超时重传2次 SYN-ACK报文后，由于 tcp_synack_retries 为2，已达到最大重传次数，于是再等待一段时间(时间为上一次超时时间的2倍)，如果还是没能收到客户端的第三次握手(ACK 报文)，那么服务端就会断开连接。<br />
因为第三次是客户端进行确认ACK报文， ACK报文不会重传！</p>
<h3 id="什么是syn攻击如何避免syn攻击">什么是SYN攻击？如何避免SYN攻击？
</h3><p>就是攻击者再短时间内伪造不同的IP地址的SYN报文像服务器发送请求，服务器就会返回SYN+ACK，不会受到回应，久而久之就会导致服务器的半连接队列被占满，这样服务器不能为正常的用户服务。</p>
<ul>
<li>半连接队列（SYN队列）：就是当服务器收到SYN请求，将客户端的SYN请求加入到半连接队列中。</li>
<li>全连接队列（Accept队列）：是当服务器与客户端通过3次握手之后，就会创建一个对象这个队列中。</li>
<li>最后通过调用accpet() socket接口，从全连接队列中取出。<br />
不管是，全连接还是半连接队列，都有最大长度限制，超过限制，默认情况都会丢弃报文导致，无法与其他建立连接。SYN攻击就是主共半连接队列，当TCP半连接队列满了，就无法与客户端建立连接了。</li>
</ul>
<p>避免SYN攻击的四种办法：</p>
<ul>
<li>调大netdev_max_backlog;</li>
<li>增大TCP半连接队列</li>
<li>开启tcp_syncookies;<br>
开启这个功能就是，当半连接队列满了之后，不丢弃报文，而是根据算法，计算除一个cookie值；
把这个值放在第二次握手的应答报文中，发送给客户端
当服务器接收到客户端的应答报文时，就会检查它的合法性，如果合法就会将对象放入Accept队列
最后再调用accpet() 接口 ， 从Accept队列中取出连接。
net.ipv4.tcp_syncookies参数有3 个值：<br />
0 就是关闭该功能<br />
1 就是仅当SYN半连接队列放不下时，再启用他<br />
2 就是无条件开启功能<br /></li>
<li>减少SYN+ACK重传次数</li>
</ul>
<h2 id="tcp-连接断开">TCP 连接断开
</h2><p>这就是TCP断开连接的过程，以及双方的状态
这里要注意的一点就是只有主动断开连接，才有TIME_WAIT状态</p>
<h3 id="为什么需要四次挥手">为什么需要四次挥手？
</h3><p>因为是这样的，我们四次挥手的过程就是 ， 一方发出申请，发出申请的一方表示我想断开连接，我不会再发数据给你了，这个时候可以接收数据， 这个时候服务器回复一个确认，然后出现closed_wait 状态，这个时间，就是用来给服务器处理数据和发送消息的。等服务器数据处理完毕， 它才会发送FIN 报文来表示现在可以关闭连接，并且进入LAST_ACK状态，发起方收到来自服务器的FIN，返回ACK就会进入TIME_WAIT 状态。</p>
<h3 id="ack报文为什么不会重传">ACK报文为什么不会重传？
</h3><ul>
<li>ACK报文不消耗序列号
再TCP协议中，学列号用于表示发送的数据顺序，而ACK报文本身不携带数据，也不占序列号空间，所以不需要重传，可以通过后续发送方的响应进行判断是否ACK已经被成功接收。</li>
<li>避免重复确认的混乱
就是ACK也要进行重传，那么如果有网络波动也就可能会导致一种情况，例如发送方的数据包1，2，3 ，正常情况下接收方收到数据包1 发送ACK确认序号为2 的报文。但如果这个ACK报文被重传了好多次，发送方会认为接收方一直在等待数据包 2，因为它连续收到了确认序号为 2 的 ACK，这就暗示着数据包 2 及后续的数据包可能没有被正确接收。，没有接收到数据2，3 从而进行不必要的传输。</li>
</ul>
<h3 id="第一次挥手丢失会发生什么">第一次挥手丢失会发生什么？
</h3><p>如果第一次挥手就发生数据丢失，客户端会触发【超时重传】机制，一般Linux中默认是 7 次不同的版本和内核版本可能有所不同， 时间也是2的倍数进行翻倍的，过了这个时间，客户端就会断开连接。</p>
<h3 id="第二次挥手丢失会发生什么">第二次挥手丢失会发生什么？
</h3><p>首先发送断开请求的一方会进入FIN_WAIT_1状态，然后接收方的第二次挥手对视会导致，发送方无法确认他是否发送，它就会触发【超时重传】再进行发送FIN请求。接收方看到对方有发送了FIN请求就知道自己确认应答的消息没有发出，那么就会继续发送。但是如果还是丢失会根据一个限制超时重传的机制的数量来决定发送方会发出几次FIN请求。如果抵达了最大重传次数那么就会断开连接。
但是注意如果使用shutdown() 来进行关闭的话， 那么就要看shutdown()关闭的方式</p>
<ul>
<li>SHUT_RD：关闭接收通道，不能再从这个套接字接收数据</li>
<li>SHUT_WR：关闭发送通道，不能通过这个套接字发送数据</li>
<li>SHUT_RDWR: 同时关闭接收和发送通道<br />
这里要注意的就是，如果shutdown只关闭读取的通道，而不关闭发送的通道，内核是不会发送FIN报文的，因为内核发送FIN报文的时候要看你是否有发送数据的能力，如果你有能力他是不会发送FIN报文的。<br />
shutdown() 和 close() 的区别 ：
就是close() 有可能会导致数据的丢失，而shutdown() 可以更加灵活的控制关闭的过程，给数据缓冲的机会。 什么情况下close() 会导致数据丢失 以及为什么 shutdown（） 可以给缓冲区机会？<br />
一个套接字可以执行一次shutdown() , 但只能被close() 多次</li>
</ul>
<h3 id="第三次挥手丢失会发生什么">第三次挥手丢失会发生什么？
</h3><p>流程是这样的，当服务器接收到客户端的FIN 报文之后，内核会自动回复ACK报文，同时处于CLOSE_WAIT状态，故名思义，他就是为了等待程序自行调度close() 函数。<br />
调用这个close() 函数， 内核就会发送FIN报文，同时进入LAST_ACK状态 也就是等待最后确认应答状态。<br />
如果迟迟没有接收到客户端发送的确认应答，那么就会触发【超时重发】机制，同样这个重发次数仍然是通过tcp_orphan_retries 来控制的。<br />
再进行第二次挥手的时候客户端就会进入到FIN_WAIT_2 状态默认是 60 s 如果一直没有接收到服务器的FIN报文客户端就会关闭。</p>
<h3 id="第四次挥手丢失会发生什么">第四次挥手丢失会发生什么？
</h3><p>当客户端收到了服务器的第三次挥手的FIN报文客户端就会进入TIME_WAIT 状态 持续 2MSL ，此时服务器处于LAST_ACK 状态也就是等待最后确认的状态，但是第四次挥手丢失，就触发了服务器的【超时重传】机制，这样服务器就会再【超时重传】机制的限制内进行重发每一次重发都会导致，客户端重置2MSL定时器，直到服务器不在抵达的【超时重传】的限制后，客户端再等2MSL就关闭了，服务器会再次等待上次重传的时间的2倍 反正应该小于一分钟所以服务器会先行关闭。</p>
<h3 id="为什么tim_wiait-等待时间是2msl">为什么TIM_WIAIT 等待时间是2MSL？
</h3><p>MSL 是报文的最大生存时间， 它是任何报文再网络上存在的最长时间， 超过这个时间报文就会被丢弃。 TCP 协议是基于 IP协议的 ， IP头中有一个字段是 TTL，是IP数据报可以经过的最大路由器数，每经过一个处理它的路由器他就会减 1 ， 当TTL=0 这个数据包将被丢弃，同时发送ICMP（互联网控制报文协议）报文通知源主机。<br /></p>
<p>MSL 和 TTL的区别：MSL的单位是时间， TTL的单位是经过路由器的跳数，所以MSL应该大于TTL消耗到0 的时间，以确保报文已经自然消亡。<br />
TTL一般时间为64 ，Linux MSL的时间为30 秒 ，意味着Linux认为数据报文经过 64个路由器的时间不会超过 30 秒，如果超过了 ， 就认为报文已经消失再网络中了。<br />
至于TIME_WAIT 的时间是 2MSL  = 60 s，是比较合理的，因为再网络中我发送给你，你处理后又会发送给我，这样一来一会2MSL刚好够了。</p>
<h3 id="为什么需要time_wait-状态">为什么需要TIME_WAIT 状态？
</h3><p>主动发起关闭的一方才会，才会有TIME_WAIT 状态<br />
需要TIME_WAIT 状态有连个原因：</p>
<ul>
<li>为了保证被动关闭的一方，可以正确关闭
这个就是如果最后一次ACK确认丢失了，那么服务端就会触发【超时重传】，假设客户端没有TIME_WAIT 状态那么，进行第四次挥手之后就直接进入CLOSE 状态这个时候服务端如果向再向我发送FIN请求客户端就会放回RST 这样就导致服务器异常终止。这样的行为是不优雅的。</li>
<li>防止历史连接中的数据，被后面相同的四元组的连接错误接收 <br />
错误接收的情况，是seq 和 isn 都有是回绕的，这就意味着没有办法通过序列号来判断新老数据。
如上图：</li>
<li>服务器关闭连接之前，发送的seq = 301 被网络延迟了</li>
<li>接着，服务器以相同的四元组重新打开了连接， 这个时候之前被延迟的数据包恰好在客户端的接收窗口的范围内，那么就导致了数据错乱的问题。
所以TCP设计了TIME_WAIT 状态，以用来保证让两个方向的数据包都被丢弃，是的原来的数据包都自然消失，确保出现数据包一定是新的连接产生。<br /></li>
</ul>
<h2 id="tcp重传机制滑动窗口流量控制拥塞控制">TCP重传机制、滑动窗口、流量控制、拥塞控制
</h2><p>TCP数据包丢的情况，会用重传机制解决：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
<li>SACK</li>
<li>D-ACK</li>
</ul>
<h3 id="超时重传">超时重传
</h3><p>再发送数据的时，设定一个定时器，当超过指定的时间后，没有搜到对方的ACK确认应答报文，就会重发数据。
有两种情况会导致超时重传：</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失
介绍两个词 一个是RTT ，一个是 RTO</li>
<li>RTT 就是一个包的往返时间差值</li>
<li>RTO 是由系列根据RTT 的公式进行计算的 <br />
因为超时时间限制设置的太短和太长都不好，太短会倒是不必要的重传，是网络的负荷增大。太长呢又降低效率。
根据分析RTO因该比RTT略大一些就可以。<br />
超时重传就一个问题：就是超时周期过程相对较长，次数是由内核里面的参数来决定的，等待时间都是 2 倍的。</li>
</ul>
<h3 id="快速重传">快速重传
</h3><p>就是当客户端向服务器发送了数据，发送了5个包 ，有1，2，3，4，5 其中第二个丢失了， 但是还没有到超时的时间 ，这个时候服务器就会回复三个序列号为2 的ACK报文，这样服务器就会返回三个序列号为2 的ACK确认，在定时器之前，进行重传。<br />
但是有一个问题就是，如果他有两个包丢失了他无法直接重传，两个因为他触发快速重传触发的事第一个丢失的包的ACK2，他就会传一个包，或者传多个 ， 一个会导致效率慢，多个有重复，增加传输压力。</p>
<h3 id="sack方法">SACK方法
</h3><p>SACK就是选择重传： 就是当有数据丢失的时候可以通过TCP头部中加一个SACK的东西，它可以将已收到信息发送给发送方，这样发送方就可以只发送丢失的数据了。<br  />
例如：使用条件：要双发都支持SACK，在Linux中 ， 可以通过 net.ipv4.tcp_sack 参数打开这个功能。</p>
<h3 id="duplicate-sack">Duplicate SACK
</h3><p>Duplicate SACK  又叫D-SACK
D-SACK的好处：</p>
<ul>
<li>可以让【发送方】知道，是发出的包丢了，还是接收方回应的ACK包丢了</li>
<li>可以知道是不是【发送方】的数据包被网络延迟了</li>
<li>可以知道网络中是不是把【发送方】的数据包给复制了<br />
在Linux中可以通过net.ipv4.tcp_dsack 开启/关闭这个功能。</li>
</ul>
<h3 id="滑动窗口">滑动窗口
</h3><p>滑动窗口的概念的引入，就是提高了效率，就好比你说一句我说一句， 你和我说完话，我有点事没回复你，你就不说话了么？ 对吧不现实，而且效率太慢了。<br />
这就有了窗口这个概念，即使往返时间长，它也不会降低网络通信的效率。窗口的实现是操作系统开辟的一个缓存空间，发送方发送数据后，要将数据保存在缓存区中。如果定期到达并受到确认应答，此时数据就可以从缓存区清除了。
有了窗口，就有窗口大小，在窗口大小就是在范围内无需等待应答，可以继续发数据的最大值
窗口的大小由接收方决定：TCP头部有一个Window 字段， 就是窗口的大小，通过这个字段接收方，将字节还有多少缓存区可以接收数据告诉对方，于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</p>
<h3 id="流量控制">流量控制
</h3><p>其实就是通过控制窗口的大小来，控制流量，但是有可能导致窗口关闭，窗口关闭就又潜在的危险，就是当窗口关闭了，当接收方处理完数据，窗口增大的时候，想在发送ACK确认的话，如果这次ACK确认丢失了，就有可能导致，一种类似于死锁的现象，就是发送方等着接收方，增加窗口的大小，接收方等着发送方发送数据。<br />
如何解决窗口关闭，导致的潜在死锁的问题呢？
使用名为窗口探测的机制，来解决这个死锁的情况， 就是当窗口关闭的时候， 发送方就会启动持续定时器，哪怕是接收方发送消息已经解决完了，窗口已经增大了，也可以等这个持续计时器超时后，发送方发送窗口探针报文，来解决死锁的局面。</p>
<ul>
<li>如果还没有增大窗口，就重启持续定时器。</li>
</ul>
<h3 id="拥塞控制">拥塞控制
</h3><p>因为当，在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大。<br />
拥塞窗口cwnd 是 min (swnd , rwnd)  <br />
拥塞窗口cwnd 变化的规律 <br /></p>
<ul>
<li>只要网路中没有出现拥塞，cwnd就会增大</li>
<li>相反网络中出现了拥塞，cwnd就会减少<br />
只要【发送方】没有按时间，接收到ACK确认应答，也就是发生的【超时重传】， 就会被认为是网络拥塞。
拥塞控制主要是四个算法：</li>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复 <br />
慢启动：当发送方每收到一个ACK ， 拥塞窗口 cwnd 的大小就会加1 。<br />
慢启动算法，发包的个数是以指数增长的，慢启动门限，就是 ssthresh (slow start threshold) 状态变量。</li>
<li>当cwnd &lt; ssthresh 时， 使用慢启动算法</li>
<li>当cwnd &gt;= ssthresh 时，就会使用拥塞避免算法 <br /></li>
</ul>
<p>拥塞避免算法：就是如果，当cwnd &gt;= ssthresh 的时候 发包就不在是指数上涨的，变成了线性上涨，减小网络拥塞的概率，但是还是上涨趋势，网络慢慢进入了拥塞的状况了，于是就可能出现丢包现象，这时候就需要对丢失的数据进行重传，当触发了【重传机制】，也就是进入了【拥塞发生算法】<br /></p>
<p>拥塞发生
重传机制是会【拥塞发生算法】是不同的<br /></p>
<ul>
<li>
<p>超时重传，调用的【拥塞发生算法】就会将ssthresh  = cwnd /2 ， cwnd =1 ，重新开始【慢启动算法】，这就相当于大幅度降低了传输的数量，可能会导致卡顿。</p>
</li>
<li>
<p>在Linux 中 使用 ss -nli 命令来查看 每个TCP 连接的cwnd的初始化的值。</p>
</li>
<li>
<p>快速重传，就是比较好的方式，当发生快速重传的时候，TCP认为这种情况不严重，因为大部分没有丢失，只丢失了一小部分，所以酌情处理，cwnd = cwnd/2 , ssthresh = cwnd。 进入快速恢复算法。<br />
快速恢复</p>
</li>
<li>
<p>在快速恢复的过程中，首先 ssthresh= cwnd/2，然后 cwnd=ssthresh+3，表示网络可能出现了阻塞，所以需要减小 cwnd 以避免，加3代表快速重传时已经确认接收到了3个重复的数据包;</p>
</li>
<li>
<p>随后继续重传丢失的数据包，如果再收到重复的 ACK，那么 cwnd 增加 1。加1代表每个收到的重复的 ACK 包，都已经离开了网络。这个过程的目的是尽快将丢失的数据包发给目标。</p>
</li>
<li>
<p>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，恢复过程结束。<br />
首先，快速恢复是拥塞发生后慢启动的优化，其首要目的仍然是降低cwnd 来减缓拥塞，所以必然会出现 cwnd 从大到小的改变。<br />
其次，过程2(cwnd逐渐加1)的存在是为了尽快将丢失的数据包发给目标，从而解决拥塞的根本问题(三次相同的 ACK 导致的快速重传)，所以这一过程中 cwnd 反而是逐渐增大的。</p>
</li>
</ul>
<h2 id="tcp-一些经典的问题">TCP 一些经典的问题
</h2><h3 id="如何理解tcp是面向字节流的协议">如何理解TCP是面向字节流的协议？
</h3><p>首先TCP是面向字节流， UDP是面向报文，因为操作系统对TCP和UDP协议的发送方的机制不同。<br />
对于UDP就是当我们组装好UDP头部的时候，就会将报文交给网络层去处理，而操作系统不会对UDP进行拆分，所以发出去的UDP是一个完整的用户消息，每一个报文就是消息的边界，对于多个UDP操作系统是将UDP加入到队列中，当用户调用recvfrom() 的时候就从队列中取一个数据， 从内核拷贝给用户缓冲区。<br />
对于TCP就是，操作系统会对TCP进行拆分，可能将一个TCP报文拆分成多个，在我们发送一条数据的时候，数据可能并没有被发送，只是从应用程序拷贝到内核中协议栈中，至于什么时候发送，要看发送窗口的大小、拥塞窗口以及当前发送缓冲区的大小。我们不能认为一个用户消息，就是一个TCP报文，所以说TCP是面向字节流的。<br />
正式因为面向字节流，就容易导致粘包问题，解决粘包问题的方法：</p>
<ul>
<li>固定长度  &ndash; 不现实</li>
<li>设置特殊字符用来充当边界 &ndash; 但是消息中原本既有了这个字符就麻烦了</li>
<li>自定义消息结构  &mdash; 还是比较灵活现实的 <br /></li>
</ul>
<p>什么是PAWS机制？
当tcp_timestamps 选项开启的时候，PAWS机制就会自动开启，它的作用是防止，TCP包中的序列号放生回绕。<br />
PAWS就是为了避免这个问题的而产生的，在开启tcp_timesamps 的选项的时候， 一台机器发送所有的TCP包都会带上发送时的时间戳， PAWS要求双方一起维护最近收到数据包的时间戳， 没收到一个数据包就会读取数据包中的时间戳跟Recent TSval 的值坐比较， 如果发现数据包中的时间戳不是递增的，就代表这个数据包是过期的， 应该被丢弃；<br /></p>
<h3 id="已经建立tcp连接再次收到syn会发生什么情况">已经建立TCP连接，再次收到SYN，会发生什么情况？
</h3><p>在这样的情况例如：客户端和服务器已经建立了连接，后来客户端宕机了，客户端向服务器再次发送SYN请求， 这个时候服务器收到了客户端的SYN报文，但是服务器不知道客户端发生了宕机的情况，那么服务器就会回复一个，携带正确序列号和确认号的ACK报文，这个ACK称为 Challenge ACK 。<br />
接着客户端收到这个CHallenge ACK的报文，发现并不是自己所期望的第二次握手，那么就会回复RST，服务器收到之后就断开了连接。<br /></p>
<h3 id="如何关闭一个tcp连接">如何关闭一个TCP连接？
</h3><ul>
<li>可以直接杀死进程
是的，这个是最粗暴的方式，杀掉客户端进程和服务端进程影响的范围会有所不同<br />
在客户端杀掉进程的话，就会发送 FIN 报文，来断开这个客户端进程与服务端建立的所有 TCP 连接这种方式影响范围只有这个客户端进程所建立的连接，而其他客户端或进程不会受影响。<br />
而在服务端杀掉进程影响就大了，此时所有的 TCP 连接都会被关闭，服务端无法继续提供访问服务。<br />
很显然，直接杀死进程是不可取的， 那么我们因该使用什么方式来杀死进程呢？<br />
在Linux 中有一个交killcx的工具就是可以平滑的关闭TCP连接，他的实现方式就是，通过这个killcx 工具伪造相同的四元组，代替客户端向服务器器发送SYN 请求。也就是利用了已经建立连接的TCP，再次发送SYN请求，这个时候服务器就会回复 Challenge ACK 。<br /></li>
<li>骗取服务器回复Challenge ACK 的序列号，从中得到服务器的确认号， 伪造RST来断开连接。</li>
<li>骗取服务器回复Challenge ACK 的序列号，从中得到序列号，伪造RST来断开连接。<br />
处理killcx 工具可以做到关闭TCP，tcpkill也可以做到，但是tcpkill工具是属于被动获取序列号的，它获取序列号的方式是，在TCP 通信的时候，获取正确的序列号， 从而发送RST报文关闭。这就代表tcpkill非常不适合关闭不活跃的TCP连接。<br /></li>
</ul>
<h3 id="四次挥手中收到乱序的fin会如何处理">四次挥手中收到乱序的FIN会如何处理？
</h3><p>当收到乱序的FIN ， 会将这个乱序的数据包放入【乱序队列】中，当数据到达之后，再去判断队列中是否有FIN报文，有就会调用tcp_fin() 使状态有FIN_WAIT2 &mdash;》TIME_WAIT 状态
所以说当不会立刻进入TIME_WAIT 状态。</p>
<h3 id="在time_wait状态下的tcp连接在收到syn报文会发生什么">在TIME_WAIT状态下的TCP连接，在收到SYN报文会发生什么？
</h3><p>首先是这样的要看是否合法？ <br />
如何判断合法性呢？就是通过序列号和时间戳（开启timesample）时间戳机制后，如果双方都开启了时间戳报文：<br /></p>
<ul>
<li>判断收到的客户端SYN的【序列号】是否比上一次【服务器】期望收到的下一个序列号要大，并且SYN的【时间戳】也要比【服务器】最后一次收到的报文时间戳要大。</li>
<li>相反有一个不满足就不是合法的SYN</li>
<li>如果没有开启时间戳选项，那么单独通过判断序列号是否比上一次大 ， true 就 合法 false 就不合法。<br />
如果使合法的SYN， 就进行进行三次握手的过程， 如果是不合法的那么就返回RST报文断开连接。<br /></li>
</ul>
<p>当我们处于TIME_WAIT状态的时候，收到RST 会断开连接么？<br /></p>
<ul>
<li>如果net.ipv4.tcp_rfc1337 参数为0 ， 则会提前结束TIME_WAIT 状态，释放连接。</li>
<li>如果net.ipv4.tcp_rfc1337 参数为1 ， 则会丢弃RST报文。<br /></li>
</ul>
<h3 id="tcp的保活机制">TCP的保活机制
</h3><p>定义一个时间段，在这个时间段里面，如果没有任何关联的活动，TCP的保活机制就会开始作用，每个一个时间间隔，机会发送一个探测报文，该报文的数据非常少，如果连续几个探测报文都没有，得到回应，则就认为则这个TCP连接死亡了，系统内核将错误信息通知给上层应用程序。这个是可以修改的<br />
net.ipv4.tcp_keepalive_time= 7200;  // 保活时间为7200秒 ， 也就是在2小时内没有任何相关活动，就会开启保活机制。<br />
net.ipv4.tcp_keepalive_intvl= 75;    //每次检验的时间间隔是75 秒<br />
net.ipv4.tcp_keepalive_probes= 9;    //表示检测9次没有响应，认为对方是不可以到达，从而中断本次连接<br /></p>
<h3 id="客户端在拔掉网线之后tcp连接是否发生变化">客户端在拔掉网线之后TCP连接是否发生变化？
</h3><p>客户端拔掉网线后，并不会直接影响 TCP 连接状态。所以，拔掉网线后，TCP 连接是否还会存在，关键要看拔掉网线之后，有没有进行数据传输<br />
有数据传输的情况:</p>
<ul>
<li>在客户端拔掉网线后，如果服务端发送了数据报文，那么在服务端重传次数没有达到最大值之前，客户端就插回了网线，那么双方原本的 TCP 连接还是能正常存在，就好像什么事情都没有发生<br /></li>
<li>在客户端拔掉网线后，如果服务端发送了数据报文，在客户端插回网线之前，服务端重传次数达到了最大值时，服务端就会断开 TCP 连接。等到客户端插回网线后，向服务端发送了数据，因为服务端已经断开了与客户端相同四元组的 TCP 连接，所以就会回 RST 报文，客户端收到后就会断开 TCP 连接。至此，双方的 TCP 连接都断开了<br />
没有数据传输的情况:</li>
<li>如果双方都没有开启 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，那么客户端和服务端的 TCP 连接状态将会一直保持存在</li>
<li>如果双方都开启了 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，TCPkeepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接。而如果在 TCP 探测期间客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在<br /></li>
</ul>
<h3 id="服务器没有listen客户端发起连接会发生什么">服务器没有listen，客户端发起连接会发生什么？
</h3><p>当服务器只绑定了IP地址和端口号，而没有调用listen 的话， 然后客户端对服务器发起建立连接，服务器会返回RST报文，来解除连接<br />
Linux内核处理收到TCP报文的入口函数是 tcp_v4_rcv ，在收到报文之后，会调用 _inet_lookup_skb函数查找TCP报文所属socket 。然后会查找监听套接字，根据目的地址和端口算出哈希值，然后再哈希表中找到对应监听改端口socket。没有找到那么就会直接返回RST报文，来断开连接。</p>
<h3 id="没有accept-能建立tcp连接么">没有accept， 能建立TCP连接么？
</h3><p>可以建立，因为三次握手的过程是不需要accept()的参与也能够完成的，其实accpet（）的作用就是从全连接队列里面将sock取出来，而其还是再握手之后才会调用accept() 。</p>
<ul>
<li>全连接队列：底层是一个链表， 因为里面存储的是已经建立连接的一些已完成三次握手的连接信息，通过调用accept()，函数来取出进行进一步的处理，从而创建一个真正用于数据传输的 socket  。因为这样的特性所以只要从头取就行，这个过程就是O(1) 的 。</li>
<li>半连接队列：底层是一个哈希表，因为再队列中储存的是一些未完成三次握手，建立连接的信息，当三次握手完成我们就要将相应的IP端口的连接取出，所以我们要使用查询效率快的那就是哈希表，时间复杂度就是O（1）。</li>
</ul>
<h3 id="全连接队列满了会怎么样">全连接队列满了会怎么样？
</h3><p>分为两种情况：</p>
<ul>
<li>tcp_abort_on_overflow  =  1  会直接向客户端发送RST报文 。</li>
<li>tcp_abort_on_overflow  =  0 的时候会将最后一次客户端发送的ACK丢弃。</li>
</ul>
<h3 id="tcp四次挥手可以变成三次么">TCP四次挥手，可以变成三次么？
</h3><p>在一定情况下使可以的，本身这个四次挥手再第二次挥手后 ， 如果没有数据是可以将三次挥手变成四次挥手的 ，但是这建立再没有数据的前提下。如果四次挥手就变成三次的话，如果有数据要发送就不好处理了。</p>
<h3 id="什么情况下会发生三次挥手">什么情况下会发生三次挥手？
</h3><p>当被动关闭的一方没有数据要发送并且【开启了TCP 延迟确认机制】 ， 那么第二次和第三次挥手就会关闭。这个延迟确认机制是默认打开的。<br />
什么是确认延迟机制：</p>
<ul>
<li>当有响应的数据要发送的时候， ACK会随着响应数据一起立刻发送给对方。</li>
<li>当没有响应数据要发送时，ACK将会延迟一段时间，以等待是否有由响应的数据可以一起发送</li>
<li>如果在延迟等待发送ACK期间，对方的第二个数据报文又到达了，那么就会立刻发送ACK</li>
</ul>
<h3 id="优雅关闭shutdown-和-暴力关闭close">优雅关闭（shutdown） 和 暴力关闭（close）
</h3><ul>
<li>close()  ， 同时关闭socket的发送和读取方向， 也就是socket 不在有发送和读取的能力，这个时候内核就会像对方发送FIN报文 ，进行四次挥手， 但是如果使多进程/线程的情况向，共享一个socket，这样你 调用了close() 只是将 socket的引用计数-1 ， 并不会导致socket 不可用， 内核也就不会发送FIN 报文，这样不影响其他进程的读写操作，知道引用计数变为0 ，才发送FIN报文。</li>
<li>shutdown() ，可以指定socket以那种发生进行关闭，如果使关闭发送方向，那么socket就没有了发送能力，但是还有接收数据的能力，如果使多线程/进程，共享一个socket，shutdown也不会管引用计数，直接就导致socket不可以用了  ，然后发送FIN报文，别的进程也用不了。</li>
<li>SHUT_RD：关闭接收通道，不能再从这个套接字接收数据</li>
<li>SHUT_WR：关闭发送通道，不能通过这个套接字发送数据</li>
<li>SHUT_RDWR: 同时关闭接收和发送通道<br />
调用close() ，这个时候同时关闭了发送和读写能力，这个时候也会完成四次会后只不过都是由操作系统来帮助我们完成四次挥手的过程，但是这个时候如果服务器再第二次挥手和第三次挥手的过程中发送数据，这部分数据就丢失了。因为关闭了接收和发送通道。<br />
调用shutdown()  ，需要注意的是虽然有多种方式去关闭通道但是如果保留了【发送通道】代表这个socket还拥有发送的能力，那么内核就不会发送FIN报文。<br /></li>
</ul>

</section>


    <footer class="article-footer">
    

    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2023 - 
        
        2024 吴宏伟
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.26.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/hugo-whw/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
