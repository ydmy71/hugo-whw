<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>测试方法 on 吴宏伟✊</title>
        <link>https://ydmy71.github.io/hugo-whw/categories/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/</link>
        <description>Recent content in 测试方法 on 吴宏伟✊</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>吴宏伟</copyright>
        <lastBuildDate>Sat, 15 Jun 2024 17:34:23 +0800</lastBuildDate><atom:link href="https://ydmy71.github.io/hugo-whw/categories/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Jmeter</title>
        <link>https://ydmy71.github.io/hugo-whw/p/jmeter/</link>
        <pubDate>Sat, 15 Jun 2024 17:34:23 +0800</pubDate>
        
        <guid>https://ydmy71.github.io/hugo-whw/p/jmeter/</guid>
        <description>&lt;img src="https://ydmy71.github.io/hugo-whw/p/jmeter/jmeter.jpg" alt="Featured image of post Jmeter" /&gt;&lt;h2 id=&#34;测试&#34;&gt;测试
&lt;/h2&gt;&lt;h3 id=&#34;软件测试&#34;&gt;软件测试
&lt;/h3&gt;&lt;p&gt;软件测试定义及目的&lt;/br&gt;
在规定条件下对程序进行操作，发现程序错误，衡量软件质量&lt;/br&gt;
目的就是尽可能多的发现软件缺陷&lt;/br&gt;&lt;/p&gt;
&lt;h3 id=&#34;软件测试分类&#34;&gt;软件测试分类
&lt;/h3&gt;&lt;h4 id=&#34;1按开发阶段分类&#34;&gt;1.按开发阶段分类
&lt;/h4&gt;&lt;p&gt;单元测试，单元测试是微小规模的测试；以测试某个功能或代码块&lt;/br&gt;
集成测试，集成测试是指一个应用系统的各个部件的联合测试，以决定他们能否在一起共同工作并没有冲突。 部件可以是代码块、独立的应用、网络上的客户端或服务器端程序。这种类型的测试尤其与客户服务器和分布式系统有关。一般集成测试以前，单元测试需要完成。&lt;/br&gt;
系统测试，系统测试是基于系统整体需求说明书的黑盒类测试，应覆盖系统所有联合的部件。系统测试是针对整个产品系统进行的测试，目的是验证系统是否满足了需求规格的定义，找出与需求规格不相符合或与之矛盾的地方。&lt;/br&gt;
验收测试，验收测试是部署软件之前的最后一个测试操作。 在软件产品完成了单元测试、集成测试和系统测试之后，产品发布之前所进行的软件测试活动。它是技术测试的最后一个阶段，也称为交付测试。验收测试的目的是确保软件准备就绪，并且可以让最终用户将其用于执行软件的既定功能和任务。&lt;/br&gt;&lt;/p&gt;
&lt;h4 id=&#34;2软件结构和算法角度&#34;&gt;2.软件结构和算法角度
&lt;/h4&gt;&lt;p&gt;黑盒测试：称为功能测试，通过测试来检验每个功能是否实现，把程序比喻成黑盒，在完全不考虑程序内部实现的情况下，对接口进行测试，功能对比需求文档是否是西安。&lt;/br&gt;
白盒测试：对软件代码实现的细节做细致检查。程序员必须全面了解程序的内部逻辑结构，对逻辑结构进行测试&lt;/br&gt;
灰盒测试：介于黑，白测试之间，灰盒关注输入数据，输出数据正确性，同时也关注内部实现&lt;/br&gt;&lt;/p&gt;
&lt;h4 id=&#34;3按软件的测试面划分&#34;&gt;3.按软件的测试面划分
&lt;/h4&gt;&lt;p&gt;功能测试，性能测试，空间性能，时间性能&lt;/p&gt;
&lt;h4 id=&#34;5软件的测试周期划分&#34;&gt;5软件的测试周期划分
&lt;/h4&gt;&lt;p&gt;冒烟测试，回归测试，随机测试，安全测试&lt;/br&gt;
冒烟测试：在对一个新版本进行大规模的系统测试之前，先验证软件的基本功能是否实现，是否具备可测性&lt;/br&gt;
回归测试：开发人员修改bug后，修饰旧代码，重新进行测试&lt;/br&gt;
随机测试：所有输入的数据都是随机产生，目的模拟用户真实操作，发现边缘性错误&lt;/br&gt;
安全测试：开发过程完成到发布阶段，对产品进行校验，验证产品符合安全需求定义，产品质量标准&lt;/br&gt;&lt;/p&gt;
&lt;h4 id=&#34;测试用例应该包括什么内容&#34;&gt;测试用例应该包括什么内容
&lt;/h4&gt;&lt;p&gt;测试用例编号&lt;/br&gt;
测试项目&lt;/br&gt;
测试用例标题&lt;/br&gt;
重要级别&lt;/br&gt;
预置条件&lt;/br&gt;
测试输入&lt;/br&gt;
操作步骤&lt;/br&gt;
预期结果&lt;/br&gt;
实际结果&lt;/br&gt;
备注&lt;/br&gt;&lt;/p&gt;
&lt;h3 id=&#34;自动化测试&#34;&gt;自动化测试
&lt;/h3&gt;&lt;p&gt;它是一种使用特定的软件工具和脚本，以自动执行测试用例并验证系统功能和性能的方法。&lt;/br&gt;
优势有，可以提高测试效率，增强测试的准确性和可靠性，提高软件质量&lt;/p&gt;
&lt;h3 id=&#34;jmeter可以做哪些测试&#34;&gt;Jmeter可以做哪些测试
&lt;/h3&gt;&lt;h4 id=&#34;并发测试&#34;&gt;并发测试
&lt;/h4&gt;&lt;p&gt;使用同步计时器，同步计时器主要有两个参数&lt;/br&gt;
模拟用户的数量：并发数&lt;/br&gt;
超时时间：设置等待时间，如果为0则永久等待，直到满足模拟的用户数&lt;/br&gt;
非0的话，则等待指定时间，如果在时间内，则满足条件就释放，否则超时释放&lt;/br&gt;&lt;/p&gt;
&lt;h4 id=&#34;稳定性测试&#34;&gt;稳定性测试
&lt;/h4&gt;&lt;p&gt;主要作用：测试持续一段时间访问接口，测试接口的稳定性&lt;/br&gt;
主要配置：线程组设置循环次数永久。&lt;/br&gt;
添加统一随机定时器&lt;/br&gt;&lt;/p&gt;
&lt;h4 id=&#34;业务场景测试&#34;&gt;业务场景测试
&lt;/h4&gt;&lt;p&gt;测试多个接口调用，模拟真实场景中接口调用，证据增加统一随机定时器模拟用户真实操作，比如用户下单过程&lt;/br&gt;
使用事务控制器 &lt;/br&gt;
进行管理这些接口，这些接口属于一个事务流程，只要有一个测试失败，则事务通过失败&lt;/br&gt;&lt;/p&gt;
&lt;h4 id=&#34;负载测试&#34;&gt;负载测试
&lt;/h4&gt;&lt;p&gt;测试一个接口或者一个业务场景的支持量&lt;/br&gt;&lt;/p&gt;
&lt;h4 id=&#34;jmeter主要元件&#34;&gt;Jmeter主要元件
&lt;/h4&gt;&lt;p&gt;1.测试计划：是使用jmeter进行测试的起点，它是其它Jmeter测试元件的容器&lt;/br&gt;
2线程组：代表一定数量的用户，它可以用来模拟用户并发发送请求。实际的请求内容在Sampler中定义，它被线程组所包含&lt;/br&gt;
3配置元件：维护Sampler需要的配置信息，并根据实际的需要修改请求的内容。&lt;/br&gt;
4.前置处理器：负责在请求之前工作，常用来修改请求的配置&lt;/br&gt;
5.定时器：负责定义请求之间的延迟间隔。&lt;/br&gt;
6.取样器：是性能测试中向服务器发送请求，记录响应信息，响应时间的最小单元。&lt;/br&gt;
7.后置处理器：负责在请求之后工作，常用获取返回的值。&lt;/br&gt;
8.断言：用来判断请求响应的结果是否如用户所期望的&lt;/br&gt;。
9.监听器：负责收集测试结果，同时确定结果显示的方式。&lt;/br&gt;
10.逻辑控制器：可以自定义Jmeter发送请求的行为逻辑，它与Sampler结合使用可以模拟复杂的请求序列。&lt;/br&gt;&lt;/p&gt;
&lt;h3 id=&#34;token&#34;&gt;token
&lt;/h3&gt;&lt;p&gt;是服务端生成的一串字符串，作为客户端进行请求的一个令牌。&lt;/p&gt;
&lt;h3 id=&#34;抽象工厂模式&#34;&gt;抽象工厂模式
&lt;/h3&gt;&lt;p&gt;围绕一个超级工厂创建其他工厂，该超级工厂又被称为其他工厂的工厂。
抽象工厂模式提供了一种创建一系列相关或相互依赖对象的接口，而无需指定具体实现类，通过使用抽象工厂模式，可以将客户端与具体产品的创建过程解耦，使得客户端可以通过工厂接口来创建一族产品。&lt;/br&gt;
结构：&lt;/br&gt;
抽象工厂：声明了一组用于创建产品对象的方法，每个方法对应一种产品类型，抽象工厂可以是接口或抽象类。&lt;/br&gt;
具体工厂：实现了抽象工厂接口，负责创建具体产品对象的实例&lt;/br&gt;
抽象产品：定义了一组产品对象的共同接口或抽象类，描述了产品对象的公共方法。&lt;/br&gt;
具体产品：实现了抽象产品接口，定义了具体产品的特定行为和属性。&lt;/br&gt;&lt;/p&gt;
&lt;h3 id=&#34;单例模式&#34;&gt;单例模式
&lt;/h3&gt;&lt;p&gt;单例模式的主要目的是限制一个类的实例化，只允许创建一个对象，这样可以在整个应用程序中共享同一个实例，从而减少资源消耗，提高性能，并方便对共享资源的管理和控制。&lt;/br&gt;
确保一个类只有一个实例，并提供一个全局访问点来访问该实例&lt;/br&gt;&lt;/p&gt;
&lt;h4 id=&#34;懒汉模式和饿汉模式的区别&#34;&gt;懒汉模式和饿汉模式的区别
&lt;/h4&gt;&lt;p&gt;初始化时间：&lt;/br&gt;
饿汉模式：在类加载的时候就实例化，即类加载只有一次，初始化时间较早。&lt;/br&gt;
懒汉模式：在类加载的时候没有直接实例化，而是在第一次调用指定实例方法的时候才进行实例化，因此初始化时间较晚。&lt;/br&gt;
线程安全性：&lt;/br&gt;
饿汉模式：由于在类加载的时候就实例化了，所有不存在多线程并发访问的问题，因此是线程安全的。&lt;/br&gt;
懒汉模式：在多线程环境下，懒汉模式本身是非线程安全的。如果多个线程同时进入了创建对象的判断条件，可能会创建多个对象。因此，懒汉模式需要通过加锁等方式保证线程安全。&lt;/br&gt;
资源占用和性能：&lt;/br&gt;
饿汉模式：在类加载的时候就创建了对象，会占用一定的内存空间，但相应的，由于资源已经初始化，第一次调用的速度也会更快，性能相对较好。&lt;/br&gt;
懒汉模式：会延迟加载，在第一次使用本单例才会出现实例对象，第一次调用需要做初始化，如果需要做的工作比较多，性能会有所延迟，但避免了不必要的内存占用。&lt;/br&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
